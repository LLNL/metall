<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Metall: metall::container::string_key_store&lt; _value_type, allocator_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Metall
   &#160;<span id="projectnumber">v0.28</span>
   </div>
   <div id="projectbrief">A persistent memory allocator for data-centric analytics</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmetall_1_1container_1_1string__key__store.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmetall_1_1container_1_1string__key__store-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">metall::container::string_key_store&lt; _value_type, allocator_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A ke-value store that uses string for its key.  
 <a href="classmetall_1_1container_1_1string__key__store.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="string__key__store_8hpp_source.html">/home/runner/work/metall/metall/include/metall/container/string_key_store.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2d91d0be1075fa4ea9e7cf59bebeb31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> = std::string_view</td></tr>
<tr class="separator:af2d91d0be1075fa4ea9e7cf59bebeb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f68a8245a1bd57cb5b04726c72304e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> = _value_type</td></tr>
<tr class="separator:a89f68a8245a1bd57cb5b04726c72304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8192b6e8a9563bbb11f22f3f4d97e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> = <a class="el" href="classmetall_1_1container_1_1string__key__store__locator.html">string_key_store_locator</a>&lt; typename map_type::const_iterator &gt;</td></tr>
<tr class="separator:aec8192b6e8a9563bbb11f22f3f4d97e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d9d749adfe178c2c30f168b42ca7b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a4d9d749adfe178c2c30f168b42ca7b2e">string_key_store</a> (const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr class="memdesc:a4d9d749adfe178c2c30f168b42ca7b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#a4d9d749adfe178c2c30f168b42ca7b2e">More...</a><br /></td></tr>
<tr class="separator:a4d9d749adfe178c2c30f168b42ca7b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47aa0197aed41b6220dc6462a90f73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aff47aa0197aed41b6220dc6462a90f73">string_key_store</a> (const bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a927921630ead4b009913d9504bdc8165">unique</a>, const uint64_t <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a37ab4c010ed5f14f0d44944e33bf09af">hash_seed</a>, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr class="memdesc:aff47aa0197aed41b6220dc6462a90f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#aff47aa0197aed41b6220dc6462a90f73">More...</a><br /></td></tr>
<tr class="separator:aff47aa0197aed41b6220dc6462a90f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f7ad526ac8b57d5a7063d27e3132ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a99f7ad526ac8b57d5a7063d27e3132ae">string_key_store</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;)=default</td></tr>
<tr class="memdesc:a99f7ad526ac8b57d5a7063d27e3132ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#a99f7ad526ac8b57d5a7063d27e3132ae">More...</a><br /></td></tr>
<tr class="separator:a99f7ad526ac8b57d5a7063d27e3132ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f0d8c00a15d519ce1b5ed68f8aab9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a1d3f0d8c00a15d519ce1b5ed68f8aab9">string_key_store</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;other, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:a1d3f0d8c00a15d519ce1b5ed68f8aab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended copy constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#a1d3f0d8c00a15d519ce1b5ed68f8aab9">More...</a><br /></td></tr>
<tr class="separator:a1d3f0d8c00a15d519ce1b5ed68f8aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9409c3381d7c6b2353fd521f42d63c0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a9409c3381d7c6b2353fd521f42d63c0c">string_key_store</a> (<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a9409c3381d7c6b2353fd521f42d63c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#a9409c3381d7c6b2353fd521f42d63c0c">More...</a><br /></td></tr>
<tr class="separator:a9409c3381d7c6b2353fd521f42d63c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b451bd5ff33acb964d1dfb58ce24d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aa33b451bd5ff33acb964d1dfb58ce24d">string_key_store</a> (<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;&amp;other, const allocator_type &amp;alloc) noexcept</td></tr>
<tr class="memdesc:aa33b451bd5ff33acb964d1dfb58ce24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-extended move constructor.  <a href="classmetall_1_1container_1_1string__key__store.html#aa33b451bd5ff33acb964d1dfb58ce24d">More...</a><br /></td></tr>
<tr class="separator:aa33b451bd5ff33acb964d1dfb58ce24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c3bd79cb08f402093604463468847e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a67c3bd79cb08f402093604463468847e">operator=</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;)=default</td></tr>
<tr class="memdesc:a67c3bd79cb08f402093604463468847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classmetall_1_1container_1_1string__key__store.html#a67c3bd79cb08f402093604463468847e">More...</a><br /></td></tr>
<tr class="separator:a67c3bd79cb08f402093604463468847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6103ab61b64d41bb613153e23244ff1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a6103ab61b64d41bb613153e23244ff1e">operator=</a> (<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a6103ab61b64d41bb613153e23244ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classmetall_1_1container_1_1string__key__store.html#a6103ab61b64d41bb613153e23244ff1e">More...</a><br /></td></tr>
<tr class="separator:a6103ab61b64d41bb613153e23244ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a68d3eb267183f5174cca7886dfcf45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a8a68d3eb267183f5174cca7886dfcf45">insert</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>)</td></tr>
<tr class="memdesc:a8a68d3eb267183f5174cca7886dfcf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a key with the default value. If the unique parameter in the constructor was set to true and a duplicate key item already exists, this function does nothing and returns false.  <a href="classmetall_1_1container_1_1string__key__store.html#a8a68d3eb267183f5174cca7886dfcf45">More...</a><br /></td></tr>
<tr class="separator:a8a68d3eb267183f5174cca7886dfcf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4f4f0539291ec7c85c3509f0795fed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aef4f4f0539291ec7c85c3509f0795fed">insert</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>, const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#ab77c7bd849d49868d10e5828aa329553">value</a>)</td></tr>
<tr class="memdesc:aef4f4f0539291ec7c85c3509f0795fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an item. Suppose the unique parameter was set to true in the constructor and a duplicate key item exists. In that case, this function just updates the value of the existing one.  <a href="classmetall_1_1container_1_1string__key__store.html#aef4f4f0539291ec7c85c3509f0795fed">More...</a><br /></td></tr>
<tr class="separator:aef4f4f0539291ec7c85c3509f0795fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9205e0f1d9be1257aae9f7a65927ff1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a9205e0f1d9be1257aae9f7a65927ff1d">insert</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>, <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;&amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#ab77c7bd849d49868d10e5828aa329553">value</a>)</td></tr>
<tr class="memdesc:a9205e0f1d9be1257aae9f7a65927ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert() with move operator version.  <a href="classmetall_1_1container_1_1string__key__store.html#a9205e0f1d9be1257aae9f7a65927ff1d">More...</a><br /></td></tr>
<tr class="separator:a9205e0f1d9be1257aae9f7a65927ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5eed76d316015c4e5da9bc2d3c5325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a4b5eed76d316015c4e5da9bc2d3c5325">clear</a> ()</td></tr>
<tr class="memdesc:a4b5eed76d316015c4e5da9bc2d3c5325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all contents. This call does not reduce the memory usage.  <a href="classmetall_1_1container_1_1string__key__store.html#a4b5eed76d316015c4e5da9bc2d3c5325">More...</a><br /></td></tr>
<tr class="separator:a4b5eed76d316015c4e5da9bc2d3c5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7f9b24e90ba262fe73bc291186624c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec7f9b24e90ba262fe73bc291186624c">count</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>) const</td></tr>
<tr class="memdesc:aec7f9b24e90ba262fe73bc291186624c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of items associated with the key.  <a href="classmetall_1_1container_1_1string__key__store.html#aec7f9b24e90ba262fe73bc291186624c">More...</a><br /></td></tr>
<tr class="separator:aec7f9b24e90ba262fe73bc291186624c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cacb5b4b3bd8695af6b0cc0e29c74d2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a8cacb5b4b3bd8695af6b0cc0e29c74d2">size</a> () const</td></tr>
<tr class="memdesc:a8cacb5b4b3bd8695af6b0cc0e29c74d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this container.  <a href="classmetall_1_1container_1_1string__key__store.html#a8cacb5b4b3bd8695af6b0cc0e29c74d2">More...</a><br /></td></tr>
<tr class="separator:a8cacb5b4b3bd8695af6b0cc0e29c74d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68379a45724225d32d286cfec11d32ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;position) const</td></tr>
<tr class="memdesc:a68379a45724225d32d286cfec11d32ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key of the element at 'position'.  <a href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">More...</a><br /></td></tr>
<tr class="separator:a68379a45724225d32d286cfec11d32ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77c7bd849d49868d10e5828aa329553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#ab77c7bd849d49868d10e5828aa329553">value</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;position)</td></tr>
<tr class="memdesc:ab77c7bd849d49868d10e5828aa329553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the element at 'position'.  <a href="classmetall_1_1container_1_1string__key__store.html#ab77c7bd849d49868d10e5828aa329553">More...</a><br /></td></tr>
<tr class="separator:ab77c7bd849d49868d10e5828aa329553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c902955c7aa7dc00f20ccfea38ca3cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a0c902955c7aa7dc00f20ccfea38ca3cc">value</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;position) const</td></tr>
<tr class="memdesc:a0c902955c7aa7dc00f20ccfea38ca3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the element at 'position'.  <a href="classmetall_1_1container_1_1string__key__store.html#a0c902955c7aa7dc00f20ccfea38ca3cc">More...</a><br /></td></tr>
<tr class="separator:a0c902955c7aa7dc00f20ccfea38ca3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cd069bc8be061f353ac249ed1c8ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a24cd069bc8be061f353ac249ed1c8ce1">find</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>) const</td></tr>
<tr class="memdesc:a24cd069bc8be061f353ac249ed1c8ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to 'key'.  <a href="classmetall_1_1container_1_1string__key__store.html#a24cd069bc8be061f353ac249ed1c8ce1">More...</a><br /></td></tr>
<tr class="separator:a24cd069bc8be061f353ac249ed1c8ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afc1bde1a13fd21fa5ff9667e19cd13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>, <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a5afc1bde1a13fd21fa5ff9667e19cd13">equal_range</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>) const</td></tr>
<tr class="memdesc:a5afc1bde1a13fd21fa5ff9667e19cd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with key key in the container.  <a href="classmetall_1_1container_1_1string__key__store.html#a5afc1bde1a13fd21fa5ff9667e19cd13">More...</a><br /></td></tr>
<tr class="separator:a5afc1bde1a13fd21fa5ff9667e19cd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab199e6df92d290b5dbfb8fc55d3edbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#ab199e6df92d290b5dbfb8fc55d3edbc7">begin</a> () const</td></tr>
<tr class="memdesc:ab199e6df92d290b5dbfb8fc55d3edbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator that points the first element in the container.  <a href="classmetall_1_1container_1_1string__key__store.html#ab199e6df92d290b5dbfb8fc55d3edbc7">More...</a><br /></td></tr>
<tr class="separator:ab199e6df92d290b5dbfb8fc55d3edbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278dfc121cf9644a819c00e4b81c367a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a278dfc121cf9644a819c00e4b81c367a">end</a> () const</td></tr>
<tr class="memdesc:a278dfc121cf9644a819c00e4b81c367a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element.  <a href="classmetall_1_1container_1_1string__key__store.html#a278dfc121cf9644a819c00e4b81c367a">More...</a><br /></td></tr>
<tr class="separator:a278dfc121cf9644a819c00e4b81c367a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154057de940d8ee5364132bb0622dad6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a154057de940d8ee5364132bb0622dad6">erase</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a68379a45724225d32d286cfec11d32ca">key</a>)</td></tr>
<tr class="memdesc:a154057de940d8ee5364132bb0622dad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements with the key equivalent to key.  <a href="classmetall_1_1container_1_1string__key__store.html#a154057de940d8ee5364132bb0622dad6">More...</a><br /></td></tr>
<tr class="separator:a154057de940d8ee5364132bb0622dad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25481727e6de6259f837bc8b721d182e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a25481727e6de6259f837bc8b721d182e">erase</a> (const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;position)</td></tr>
<tr class="memdesc:a25481727e6de6259f837bc8b721d182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at 'position'.  <a href="classmetall_1_1container_1_1string__key__store.html#a25481727e6de6259f837bc8b721d182e">More...</a><br /></td></tr>
<tr class="separator:a25481727e6de6259f837bc8b721d182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e828abbfb44c1aa91da52703871fdde"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a4e828abbfb44c1aa91da52703871fdde">max_id_probe_distance</a> () const</td></tr>
<tr class="memdesc:a4e828abbfb44c1aa91da52703871fdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum ID probe distance. In other words, the maximum number of key pairs that have the same hash value.  <a href="classmetall_1_1container_1_1string__key__store.html#a4e828abbfb44c1aa91da52703871fdde">More...</a><br /></td></tr>
<tr class="separator:a4e828abbfb44c1aa91da52703871fdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149b2d17071711d0d11f501b61668309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a149b2d17071711d0d11f501b61668309">rehash</a> ()</td></tr>
<tr class="memdesc:a149b2d17071711d0d11f501b61668309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehash elements.  <a href="classmetall_1_1container_1_1string__key__store.html#a149b2d17071711d0d11f501b61668309">More...</a><br /></td></tr>
<tr class="separator:a149b2d17071711d0d11f501b61668309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a6c87432cfd8fe68fbbc9f5df8f390"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#ab7a6c87432cfd8fe68fbbc9f5df8f390">get_allocator</a> ()</td></tr>
<tr class="memdesc:ab7a6c87432cfd8fe68fbbc9f5df8f390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of the internal allocator.  <a href="classmetall_1_1container_1_1string__key__store.html#ab7a6c87432cfd8fe68fbbc9f5df8f390">More...</a><br /></td></tr>
<tr class="separator:ab7a6c87432cfd8fe68fbbc9f5df8f390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927921630ead4b009913d9504bdc8165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a927921630ead4b009913d9504bdc8165">unique</a> () const</td></tr>
<tr class="memdesc:a927921630ead4b009913d9504bdc8165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this container inserts keys uniquely.  <a href="classmetall_1_1container_1_1string__key__store.html#a927921630ead4b009913d9504bdc8165">More...</a><br /></td></tr>
<tr class="separator:a927921630ead4b009913d9504bdc8165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab4c010ed5f14f0d44944e33bf09af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a37ab4c010ed5f14f0d44944e33bf09af">hash_seed</a> () const</td></tr>
<tr class="memdesc:a37ab4c010ed5f14f0d44944e33bf09af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash seed.  <a href="classmetall_1_1container_1_1string__key__store.html#a37ab4c010ed5f14f0d44944e33bf09af">More...</a><br /></td></tr>
<tr class="separator:a37ab4c010ed5f14f0d44944e33bf09af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _value_type, typename allocator_type = metall::manager::allocator_type&lt;std::byte&gt;&gt;<br />
class metall::container::string_key_store&lt; _value_type, allocator_type &gt;</h3>

<p>A ke-value store that uses string for its key. </p>
<dl class="section warning"><dt>Warning</dt><dd>This container is designed to work as the top-level container, i.e., it does not work if used inside another container. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_value_type</td><td>A value type. </td></tr>
    <tr><td class="paramname">allocator_type</td><td>An allocator type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af2d91d0be1075fa4ea9e7cf59bebeb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d91d0be1075fa4ea9e7cf59bebeb31">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> =  std::string_view</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89f68a8245a1bd57cb5b04726c72304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f68a8245a1bd57cb5b04726c72304e">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> =  _value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec8192b6e8a9563bbb11f22f3f4d97e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8192b6e8a9563bbb11f22f3f4d97e0">&#9670;&nbsp;</a></span>locator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> =  <a class="el" href="classmetall_1_1container_1_1string__key__store__locator.html">string_key_store_locator</a>&lt;typename map_type::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4d9d749adfe178c2c30f168b42ca7b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9d749adfe178c2c30f168b42ca7b2e">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff47aa0197aed41b6220dc6462a90f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47aa0197aed41b6220dc6462a90f73">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>hash_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unique</td><td>Accept duplicate keys if false is specified. </td></tr>
    <tr><td class="paramname">hash_seed</td><td>Hash function seed. </td></tr>
    <tr><td class="paramname">allocator</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99f7ad526ac8b57d5a7063d27e3132ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f7ad526ac8b57d5a7063d27e3132ae">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a1d3f0d8c00a15d519ce1b5ed68f8aab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3f0d8c00a15d519ce1b5ed68f8aab9">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended copy constructor. </p>

</div>
</div>
<a id="a9409c3381d7c6b2353fd521f42d63c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9409c3381d7c6b2353fd521f42d63c0c">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="aa33b451bd5ff33acb964d1dfb58ce24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b451bd5ff33acb964d1dfb58ce24d">&#9670;&nbsp;</a></span>string_key_store() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::<a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocator-extended move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67c3bd79cb08f402093604463468847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c3bd79cb08f402093604463468847e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&amp; <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a6103ab61b64d41bb613153e23244ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6103ab61b64d41bb613153e23244ff1e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&amp; <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a>&lt; _value_type, allocator_type &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a8a68d3eb267183f5174cca7886dfcf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a68d3eb267183f5174cca7886dfcf45">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a key with the default value. If the unique parameter in the constructor was set to true and a duplicate key item already exists, this function does nothing and returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an item is inserted; otherwise, false. </dd></dl>

</div>
</div>
<a id="aef4f4f0539291ec7c85c3509f0795fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4f4f0539291ec7c85c3509f0795fed">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an item. Suppose the unique parameter was set to true in the constructor and a duplicate key item exists. In that case, this function just updates the value of the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to insert.</td></tr>
    <tr><td class="paramname">value</td><td>A value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always true. </dd></dl>

</div>
</div>
<a id="a9205e0f1d9be1257aae9f7a65927ff1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9205e0f1d9be1257aae9f7a65927ff1d">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert() with move operator version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to insert. </td></tr>
    <tr><td class="paramname">value</td><td>A value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always true. </dd></dl>

</div>
</div>
<a id="a4b5eed76d316015c4e5da9bc2d3c5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5eed76d316015c4e5da9bc2d3c5325">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all contents. This call does not reduce the memory usage. </p>

</div>
</div>
<a id="aec7f9b24e90ba262fe73bc291186624c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7f9b24e90ba262fe73bc291186624c">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of items associated with the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items associated with the key. </dd></dl>

</div>
</div>
<a id="a8cacb5b4b3bd8695af6b0cc0e29c74d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cacb5b4b3bd8695af6b0cc0e29c74d2">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in this container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in this container. </dd></dl>

</div>
</div>
<a id="a68379a45724225d32d286cfec11d32ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68379a45724225d32d286cfec11d32ca">&#9670;&nbsp;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key of the element at 'position'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A locator object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The key of the element at 'position'. </dd></dl>

</div>
</div>
<a id="ab77c7bd849d49868d10e5828aa329553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77c7bd849d49868d10e5828aa329553">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a>&amp; <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the element at 'position'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A locator object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element at 'position'. </dd></dl>

</div>
</div>
<a id="a0c902955c7aa7dc00f20ccfea38ca3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c902955c7aa7dc00f20ccfea38ca3cc">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#a89f68a8245a1bd57cb5b04726c72304e">value_type</a>&amp; <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the element at 'position'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>A locator object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element at 'position' as const. </dd></dl>

</div>
</div>
<a id="a24cd069bc8be061f353ac249ed1c8ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cd069bc8be061f353ac249ed1c8ce1">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to 'key'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of an element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An locator object that points the found element. </dd></dl>

</div>
</div>
<a id="a5afc1bde1a13fd21fa5ff9667e19cd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afc1bde1a13fd21fa5ff9667e19cd13">&#9670;&nbsp;</a></span>equal_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>, <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a>&gt; <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with key key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of elements to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of locator objects. The range is defined by two locators. The first points to the first element of the range, and the second points to the element following the last element of the range. </dd></dl>

</div>
</div>
<a id="ab199e6df92d290b5dbfb8fc55d3edbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab199e6df92d290b5dbfb8fc55d3edbc7">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator that points the first element in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points the first element in the container. </dd></dl>

</div>
</div>
<a id="a278dfc121cf9644a819c00e4b81c367a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278dfc121cf9644a819c00e4b81c367a">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a154057de940d8ee5364132bb0622dad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154057de940d8ee5364132bb0622dad6">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#af2d91d0be1075fa4ea9e7cf59bebeb31">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements with the key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of elements to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements removed. </dd></dl>

</div>
</div>
<a id="a25481727e6de6259f837bc8b721d182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25481727e6de6259f837bc8b721d182e">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1string__key__store.html#aec8192b6e8a9563bbb11f22f3f4d97e0">locator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at 'position'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position of an element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A locator that points to the next element of the removed one. </dd></dl>

</div>
</div>
<a id="a4e828abbfb44c1aa91da52703871fdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e828abbfb44c1aa91da52703871fdde">&#9670;&nbsp;</a></span>max_id_probe_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::max_id_probe_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum ID probe distance. In other words, the maximum number of key pairs that have the same hash value. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum ID probe distance. </dd></dl>

</div>
</div>
<a id="a149b2d17071711d0d11f501b61668309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149b2d17071711d0d11f501b61668309">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::rehash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rehash elements. </p>

</div>
</div>
<a id="ab7a6c87432cfd8fe68fbbc9f5df8f390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a6c87432cfd8fe68fbbc9f5df8f390">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of the internal allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>An instance of the internal allocator. </dd></dl>

</div>
</div>
<a id="a927921630ead4b009913d9504bdc8165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927921630ead4b009913d9504bdc8165">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this container inserts keys uniquely. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this container inserts key avoiding duplicates; otherwise false. </dd></dl>

</div>
</div>
<a id="a37ab4c010ed5f14f0d44944e33bf09af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ab4c010ed5f14f0d44944e33bf09af">&#9670;&nbsp;</a></span>hash_seed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _value_type , typename allocator_type  = metall::manager::allocator_type&lt;std::byte&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1string__key__store.html">metall::container::string_key_store</a>&lt; _value_type, allocator_type &gt;::hash_seed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash seed. </p>
<dl class="section return"><dt>Returns</dt><dd>Hash seed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/metall/metall/include/metall/container/<a class="el" href="string__key__store_8hpp_source.html">string_key_store.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemetall.html">metall</a></li><li class="navelem"><a class="el" href="namespacemetall_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
