<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Metall: metall::container::concurrent_map&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Metall
   &#160;<span id="projectnumber">v0.28</span>
   </div>
   <div id="projectbrief">A persistent memory allocator for data-centric analytics</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmetall_1_1container_1_1concurrent__map.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmetall_1_1container_1_1concurrent__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">metall::container::concurrent_map&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A concurrent map container which can be stored in persistent memory. This container does not allocate mutex objects internally, but allocates them as static objects. To achieve high concurrency, this container allocates multiple banks, where a bank consists of an actual STL map object and a mutex object.  
 <a href="classmetall_1_1container_1_1concurrent__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="concurrent__map_8hpp_source.html">/home/runner/work/metall/metall/include/metall/container/concurrent_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0eca3a6229fcb4959de8a648d08e0956"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> = typename internal_map_type::key_type</td></tr>
<tr class="memdesc:a0eca3a6229fcb4959de8a648d08e0956"><td class="mdescLeft">&#160;</td><td class="mdescRight">A key type.  <a href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">More...</a><br /></td></tr>
<tr class="separator:a0eca3a6229fcb4959de8a648d08e0956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7112e27eba4668b8849d0036286c61c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> = typename internal_map_type::mapped_type</td></tr>
<tr class="memdesc:a7112e27eba4668b8849d0036286c61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapped type.  <a href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">More...</a><br /></td></tr>
<tr class="separator:a7112e27eba4668b8849d0036286c61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae928cfdf86eedbdb0de6c848b3bb2004"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ae928cfdf86eedbdb0de6c848b3bb2004">value_type</a> = typename internal_map_type::value_type</td></tr>
<tr class="memdesc:ae928cfdf86eedbdb0de6c848b3bb2004"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value type (i.e., std::pair&lt;const key_type, mapped_type&gt;).  <a href="classmetall_1_1container_1_1concurrent__map.html#ae928cfdf86eedbdb0de6c848b3bb2004">More...</a><br /></td></tr>
<tr class="separator:ae928cfdf86eedbdb0de6c848b3bb2004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee97aacbd0863538359b28a9d9d028d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a> = typename internal_map_type::size_type</td></tr>
<tr class="memdesc:aee97aacbd0863538359b28a9d9d028d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unsigned integer type (usually std::size_t).  <a href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">More...</a><br /></td></tr>
<tr class="separator:aee97aacbd0863538359b28a9d9d028d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d71d3ff464014e4d91d0971400e07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a952d71d3ff464014e4d91d0971400e07">allocator_type</a> = _allocator</td></tr>
<tr class="memdesc:a952d71d3ff464014e4d91d0971400e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator type.  <a href="classmetall_1_1container_1_1concurrent__map.html#a952d71d3ff464014e4d91d0971400e07">More...</a><br /></td></tr>
<tr class="separator:a952d71d3ff464014e4d91d0971400e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370c1110d8744f56fed40d034e2dd79b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a> = <a class="el" href="classmetall_1_1utility_1_1container__of__containers__iterator__adaptor.html">metall::utility::container_of_containers_iterator_adaptor</a>&lt; typename banked_map_type::const_iterator, typename internal_map_type::const_iterator &gt;</td></tr>
<tr class="memdesc:a370c1110d8744f56fed40d034e2dd79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator type.  <a href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">More...</a><br /></td></tr>
<tr class="separator:a370c1110d8744f56fed40d034e2dd79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc1f13a6d995b36cc9b142496d17821a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#adc1f13a6d995b36cc9b142496d17821a">concurrent_map</a> (const _allocator &amp;allocator=_allocator())</td></tr>
<tr class="separator:adc1f13a6d995b36cc9b142496d17821a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2539a330792031be748a5427311804df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a2539a330792031be748a5427311804df">count</a> (const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a2539a330792031be748a5427311804df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements matching specific key.  <a href="classmetall_1_1container_1_1concurrent__map.html#a2539a330792031be748a5427311804df">More...</a><br /></td></tr>
<tr class="separator:a2539a330792031be748a5427311804df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9823111485c792cded41d7bb49a8c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ae9823111485c792cded41d7bb49a8c22">size</a> () const</td></tr>
<tr class="memdesc:ae9823111485c792cded41d7bb49a8c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="classmetall_1_1container_1_1concurrent__map.html#ae9823111485c792cded41d7bb49a8c22">More...</a><br /></td></tr>
<tr class="separator:ae9823111485c792cded41d7bb49a8c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e639d9e0e22e6f8a6e0f1573de1e2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a62e639d9e0e22e6f8a6e0f1573de1e2b">insert</a> (<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ae928cfdf86eedbdb0de6c848b3bb2004">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a62e639d9e0e22e6f8a6e0f1573de1e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container if the container doesn't already contain an element with an equivalent key.  <a href="classmetall_1_1container_1_1concurrent__map.html#a62e639d9e0e22e6f8a6e0f1573de1e2b">More...</a><br /></td></tr>
<tr class="separator:a62e639d9e0e22e6f8a6e0f1573de1e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c8a96d0cde5a00a5be1ce6406e15c6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> &amp;, std::unique_lock&lt; std::mutex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a92c8a96d0cde5a00a5be1ce6406e15c6">scoped_edit</a> (const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a92c8a96d0cde5a00a5be1ce6406e15c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a way to edit an element exclusively. If no element exists with an equivalent key, this container creates a new element with key.  <a href="classmetall_1_1container_1_1concurrent__map.html#a92c8a96d0cde5a00a5be1ce6406e15c6">More...</a><br /></td></tr>
<tr class="separator:a92c8a96d0cde5a00a5be1ce6406e15c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b863f4e10609d9f26d85457865a27c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ad1b863f4e10609d9f26d85457865a27c">edit</a> (const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;key, const std::function&lt; void(<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> &amp;mapped_value)&gt; &amp;editor)</td></tr>
<tr class="memdesc:ad1b863f4e10609d9f26d85457865a27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a way to edit an element exclusively. If no element exists with an equivalent key, this container creates a new element with key.  <a href="classmetall_1_1container_1_1concurrent__map.html#ad1b863f4e10609d9f26d85457865a27c">More...</a><br /></td></tr>
<tr class="separator:ad1b863f4e10609d9f26d85457865a27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c4724d93afa8a8078f5ba0af5406a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ad07c4724d93afa8a8078f5ba0af5406a">cbegin</a> () const</td></tr>
<tr class="memdesc:ad07c4724d93afa8a8078f5ba0af5406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the map. If the container is empty, the returned iterator will be equal to end().  <a href="classmetall_1_1container_1_1concurrent__map.html#ad07c4724d93afa8a8078f5ba0af5406a">More...</a><br /></td></tr>
<tr class="separator:ad07c4724d93afa8a8078f5ba0af5406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d55a490a92bfcfc713b4f827acc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a610d55a490a92bfcfc713b4f827acc5f">cend</a> () const</td></tr>
<tr class="memdesc:a610d55a490a92bfcfc713b4f827acc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="classmetall_1_1container_1_1concurrent__map.html#a610d55a490a92bfcfc713b4f827acc5f">More...</a><br /></td></tr>
<tr class="separator:a610d55a490a92bfcfc713b4f827acc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1093ae57cfa29f8d27a1e2334761ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#acb1093ae57cfa29f8d27a1e2334761ef">find</a> (const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:acb1093ae57cfa29f8d27a1e2334761ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with an equivalent key.  <a href="classmetall_1_1container_1_1concurrent__map.html#acb1093ae57cfa29f8d27a1e2334761ef">More...</a><br /></td></tr>
<tr class="separator:acb1093ae57cfa29f8d27a1e2334761ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d50af590eed33526dad3ac0ca4692e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a952d71d3ff464014e4d91d0971400e07">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ac0d50af590eed33526dad3ac0ca4692e">get_allocator</a> () const</td></tr>
<tr class="memdesc:ac0d50af590eed33526dad3ac0ca4692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="classmetall_1_1container_1_1concurrent__map.html#ac0d50af590eed33526dad3ac0ca4692e">More...</a><br /></td></tr>
<tr class="separator:ac0d50af590eed33526dad3ac0ca4692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _key_type, typename _mapped_type, typename _compare = std::less&lt;_key_type&gt;, typename _bank_no_hasher = std::hash&lt;_key_type&gt;, typename _allocator = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt;<br />
class metall::container::concurrent_map&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;</h3>

<p>A concurrent map container which can be stored in persistent memory. This container does not allocate mutex objects internally, but allocates them as static objects. To achieve high concurrency, this container allocates multiple banks, where a bank consists of an actual STL map object and a mutex object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_key_type</td><td>A key type. </td></tr>
    <tr><td class="paramname">_mapped_type</td><td>A mapped type. </td></tr>
    <tr><td class="paramname">_compare</td><td>A key compare. </td></tr>
    <tr><td class="paramname">_bank_no_hasher</td><td>A key hasher. </td></tr>
    <tr><td class="paramname">_allocator</td><td>An allocator. </td></tr>
    <tr><td class="paramname">k_num_banks</td><td>The number of banks to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="concurrent_map_8cpp-example.html#_a0">concurrent_map.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0eca3a6229fcb4959de8a648d08e0956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eca3a6229fcb4959de8a648d08e0956">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> =  typename internal_map_type::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A key type. </p>

</div>
</div>
<a id="a7112e27eba4668b8849d0036286c61c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7112e27eba4668b8849d0036286c61c0">&#9670;&nbsp;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> =  typename internal_map_type::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mapped type. </p>

</div>
</div>
<a id="ae928cfdf86eedbdb0de6c848b3bb2004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae928cfdf86eedbdb0de6c848b3bb2004">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ae928cfdf86eedbdb0de6c848b3bb2004">value_type</a> =  typename internal_map_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value type (i.e., std::pair&lt;const key_type, mapped_type&gt;). </p>

</div>
</div>
<a id="aee97aacbd0863538359b28a9d9d028d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee97aacbd0863538359b28a9d9d028d1">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a> =  typename internal_map_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A unsigned integer type (usually std::size_t). </p>

</div>
</div>
<a id="a952d71d3ff464014e4d91d0971400e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952d71d3ff464014e4d91d0971400e07">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a952d71d3ff464014e4d91d0971400e07">allocator_type</a> =  _allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An allocator type. </p>

</div>
</div>
<a id="a370c1110d8744f56fed40d034e2dd79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370c1110d8744f56fed40d034e2dd79b">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a> =  <a class="el" href="classmetall_1_1utility_1_1container__of__containers__iterator__adaptor.html">metall::utility::container_of_containers_iterator_adaptor</a>&lt; typename banked_map_type::const_iterator, typename internal_map_type::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const iterator type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc1f13a6d995b36cc9b142496d17821a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1f13a6d995b36cc9b142496d17821a">&#9670;&nbsp;</a></span>concurrent_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::<a class="el" href="classmetall_1_1container_1_1concurrent__map.html">concurrent_map</a> </td>
          <td>(</td>
          <td class="paramtype">const _allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>_allocator()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2539a330792031be748a5427311804df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2539a330792031be748a5427311804df">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements matching specific key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key value of the elements to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements with key that compares equivalent to key, which is either 1 or 0. </dd></dl>

</div>
</div>
<a id="ae9823111485c792cded41d7bb49a8c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9823111485c792cded41d7bb49a8c22">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#aee97aacbd0863538359b28a9d9d028d1">size_type</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="a62e639d9e0e22e6f8a6e0f1573de1e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e639d9e0e22e6f8a6e0f1573de1e2b">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#ae928cfdf86eedbdb0de6c848b3bb2004">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An element value to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool denoting whether the insertion took place. </dd></dl>

</div>
</div>
<a id="a92c8a96d0cde5a00a5be1ce6406e15c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c8a96d0cde5a00a5be1ce6406e15c6">&#9670;&nbsp;</a></span>scoped_edit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> &amp;, std::unique_lock&lt;std::mutex&gt; &gt; <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::scoped_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a way to edit an element exclusively. If no element exists with an equivalent key, this container creates a new element with key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of the element to edit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of a reference to the element and a mutex ownership wrapper. </dd></dl>

</div>
</div>
<a id="ad1b863f4e10609d9f26d85457865a27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b863f4e10609d9f26d85457865a27c">&#9670;&nbsp;</a></span>edit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a7112e27eba4668b8849d0036286c61c0">mapped_type</a> &amp;mapped_value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>editor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a way to edit an element exclusively. If no element exists with an equivalent key, this container creates a new element with key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key of the element to edit.</td></tr>
    <tr><td class="paramname">editor</td><td>A function object which edits an element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad07c4724d93afa8a8078f5ba0af5406a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07c4724d93afa8a8078f5ba0af5406a">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the map. If the container is empty, the returned iterator will be equal to end(). </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the first element. </dd></dl>

</div>
</div>
<a id="a610d55a490a92bfcfc713b4f827acc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d55a490a92bfcfc713b4f827acc5f">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the map. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="acb1093ae57cfa29f8d27a1e2334761ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1093ae57cfa29f8d27a1e2334761ef">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a370c1110d8744f56fed40d034e2dd79b">const_iterator</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a0eca3a6229fcb4959de8a648d08e0956">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key value of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to an element with an equivalent key. If no such element is found, the returned iterator will be equal to end(). </dd></dl>

</div>
</div>
<a id="ac0d50af590eed33526dad3ac0ca4692e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d50af590eed33526dad3ac0ca4692e">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _key_type , typename _mapped_type , typename _compare  = std::less&lt;_key_type&gt;, typename _bank_no_hasher  = std::hash&lt;_key_type&gt;, typename _allocator  = std::allocator&lt;std::pair&lt;const _key_type, _mapped_type&gt;&gt;, int k_num_banks = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html#a952d71d3ff464014e4d91d0971400e07">allocator_type</a> <a class="el" href="classmetall_1_1container_1_1concurrent__map.html">metall::container::concurrent_map</a>&lt; _key_type, _mapped_type, _compare, _bank_no_hasher, _allocator, k_num_banks &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>An object of the associated allocator. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/metall/metall/include/metall/container/<a class="el" href="concurrent__map_8hpp_source.html">concurrent_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemetall.html">metall</a></li><li class="navelem"><a class="el" href="namespacemetall_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html">concurrent_map</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
