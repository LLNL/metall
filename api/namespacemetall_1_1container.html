<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Metall: metall::container Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Metall
   &#160;<span id="projectnumber">v0.23.1</span>
   </div>
   <div id="projectbrief">Apersistentmemoryallocatorfordata-centricanalytics</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemetall_1_1container.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">metall::container Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for Metall container.  
<a href="namespacemetall_1_1container.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemetall_1_1container_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container_1_1experimental.html">experimental</a></td></tr>
<tr class="memdesc:namespacemetall_1_1container_1_1experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for Metall containers in an experimental phase. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1concurrent__map.html">concurrent_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concurrent map container which can be stored in persistent memory. This container does not allocate mutex objects internally, but allocates them as static objects. To achieve high concurrency, this container allocates multiple banks, where a bank consists of an actual STL map object and a mutex object.  <a href="classmetall_1_1container_1_1concurrent__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store.html">string_key_store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ke-value store that uses string for its key.  <a href="classmetall_1_1container_1_1string__key__store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1container_1_1string__key__store__locator.html">string_key_store_locator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c5339ff4df05c5ccbfef46f75bf7f0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a0c5339ff4df05c5ccbfef46f75bf7f0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a0c5339ff4df05c5ccbfef46f75bf7f0a">deque</a> = boost::container::deque&lt; T, Allocator &gt;</td></tr>
<tr class="memdesc:a0c5339ff4df05c5ccbfef46f75bf7f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deque container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a0c5339ff4df05c5ccbfef46f75bf7f0a">More...</a><br /></td></tr>
<tr class="separator:a0c5339ff4df05c5ccbfef46f75bf7f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6753db897489a2197ff3c693a04396"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aec6753db897489a2197ff3c693a04396"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#aec6753db897489a2197ff3c693a04396">list</a> = boost::container::list&lt; T, Allocator &gt;</td></tr>
<tr class="memdesc:aec6753db897489a2197ff3c693a04396"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#aec6753db897489a2197ff3c693a04396">More...</a><br /></td></tr>
<tr class="separator:aec6753db897489a2197ff3c693a04396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30d7aceb6d1ba8ab22971a4baf10621"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad30d7aceb6d1ba8ab22971a4baf10621"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ad30d7aceb6d1ba8ab22971a4baf10621">map</a> = boost::container::map&lt; Key, T, Compare, Allocator &gt;</td></tr>
<tr class="memdesc:ad30d7aceb6d1ba8ab22971a4baf10621"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ad30d7aceb6d1ba8ab22971a4baf10621">More...</a><br /></td></tr>
<tr class="separator:ad30d7aceb6d1ba8ab22971a4baf10621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd99e1d3323b5f5ee7f57e1a19e1a4"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae2cd99e1d3323b5f5ee7f57e1a19e1a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ae2cd99e1d3323b5f5ee7f57e1a19e1a4">multimap</a> = boost::container::multimap&lt; Key, T, Compare, Allocator &gt;</td></tr>
<tr class="memdesc:ae2cd99e1d3323b5f5ee7f57e1a19e1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multimap container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ae2cd99e1d3323b5f5ee7f57e1a19e1a4">More...</a><br /></td></tr>
<tr class="separator:ae2cd99e1d3323b5f5ee7f57e1a19e1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fede91b4f95ac641e5d38ff6d2e1f54"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container  = vector&lt;T&gt;, typename Compare  = std::less&lt;typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:a2fede91b4f95ac641e5d38ff6d2e1f54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a2fede91b4f95ac641e5d38ff6d2e1f54">priority_queue</a> = std::priority_queue&lt; T, Container &gt;</td></tr>
<tr class="memdesc:a2fede91b4f95ac641e5d38ff6d2e1f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A priority_queue container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a2fede91b4f95ac641e5d38ff6d2e1f54">More...</a><br /></td></tr>
<tr class="separator:a2fede91b4f95ac641e5d38ff6d2e1f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ebbafd91c00bc0bf0db55a75a5c091"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container  = deque&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac4ebbafd91c00bc0bf0db55a75a5c091"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ac4ebbafd91c00bc0bf0db55a75a5c091">queue</a> = std::queue&lt; T, Container &gt;</td></tr>
<tr class="memdesc:ac4ebbafd91c00bc0bf0db55a75a5c091"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ac4ebbafd91c00bc0bf0db55a75a5c091">More...</a><br /></td></tr>
<tr class="separator:ac4ebbafd91c00bc0bf0db55a75a5c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4cdd0d20737ad97bb9fccac276bc5"><td class="memTemplParams" colspan="2">template&lt;class OuterAlloc , class... InnerAlloc&gt; </td></tr>
<tr class="memitem:aece4cdd0d20737ad97bb9fccac276bc5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">scoped_allocator_adaptor</a> = boost::container::scoped_allocator_adaptor&lt; OuterAlloc, InnerAlloc... &gt;</td></tr>
<tr class="memdesc:aece4cdd0d20737ad97bb9fccac276bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator which can be used with multilevel containers.  <a href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">More...</a><br /></td></tr>
<tr class="separator:aece4cdd0d20737ad97bb9fccac276bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b644504f948016762c0d431162ab10"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a94b644504f948016762c0d431162ab10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a94b644504f948016762c0d431162ab10">set</a> = boost::container::set&lt; Key, Compare, Allocator &gt;</td></tr>
<tr class="memdesc:a94b644504f948016762c0d431162ab10"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a94b644504f948016762c0d431162ab10">More...</a><br /></td></tr>
<tr class="separator:a94b644504f948016762c0d431162ab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1060d4465ba278f23314fac24020f2a8"><td class="memTemplParams" colspan="2">template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a1060d4465ba278f23314fac24020f2a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a1060d4465ba278f23314fac24020f2a8">multiset</a> = boost::container::multiset&lt; Key, Compare, Allocator &gt;</td></tr>
<tr class="memdesc:a1060d4465ba278f23314fac24020f2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiset container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a1060d4465ba278f23314fac24020f2a8">More...</a><br /></td></tr>
<tr class="separator:a1060d4465ba278f23314fac24020f2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d843f18b46802f391c12875aa14f2a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container  = deque&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a45d843f18b46802f391c12875aa14f2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a45d843f18b46802f391c12875aa14f2a">stack</a> = std::stack&lt; T, Container &gt;</td></tr>
<tr class="memdesc:a45d843f18b46802f391c12875aa14f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a45d843f18b46802f391c12875aa14f2a">More...</a><br /></td></tr>
<tr class="separator:a45d843f18b46802f391c12875aa14f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4de42b06a5ec17815a15504d100745"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits  = std::char_traits&lt;CharT&gt;, class Allocator  = metall::manager::allocator_type&lt;CharT&gt;&gt; </td></tr>
<tr class="memitem:a5a4de42b06a5ec17815a15504d100745"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">basic_string</a> = boost::container::basic_string&lt; CharT, Traits, Allocator &gt;</td></tr>
<tr class="memdesc:a5a4de42b06a5ec17815a15504d100745"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">More...</a><br /></td></tr>
<tr class="separator:a5a4de42b06a5ec17815a15504d100745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe499903b179ed596cd8c2bd6892009"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">string</a> = <a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">basic_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a5fe499903b179ed596cd8c2bd6892009"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string container that uses char as its character type and Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">More...</a><br /></td></tr>
<tr class="separator:a5fe499903b179ed596cd8c2bd6892009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc3f12030cc354af58b94f53d3858c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a6efc3f12030cc354af58b94f53d3858c">wstring</a> = <a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">basic_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a6efc3f12030cc354af58b94f53d3858c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string container that uses wchar_t as its character type and Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a6efc3f12030cc354af58b94f53d3858c">More...</a><br /></td></tr>
<tr class="separator:a6efc3f12030cc354af58b94f53d3858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6538b68ed07639523fd7313e407881a"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ad6538b68ed07639523fd7313e407881a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ad6538b68ed07639523fd7313e407881a">unordered_map</a> = boost::unordered_map&lt; Key, T, Hash, KeyEqual, Allocator &gt;</td></tr>
<tr class="memdesc:ad6538b68ed07639523fd7313e407881a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unordered_map container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ad6538b68ed07639523fd7313e407881a">More...</a><br /></td></tr>
<tr class="separator:ad6538b68ed07639523fd7313e407881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46d3b3ceb781a5b55e5070639919a02"><td class="memTemplParams" colspan="2">template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt; &gt;&gt; </td></tr>
<tr class="memitem:ae46d3b3ceb781a5b55e5070639919a02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ae46d3b3ceb781a5b55e5070639919a02">unordered_multimap</a> = boost::unordered_multimap&lt; Key, T, Hash, KeyEqual, Allocator &gt;</td></tr>
<tr class="memdesc:ae46d3b3ceb781a5b55e5070639919a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unordered_multimap container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ae46d3b3ceb781a5b55e5070639919a02">More...</a><br /></td></tr>
<tr class="separator:ae46d3b3ceb781a5b55e5070639919a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69404c0f68aa2e313ea57a0dc053d6"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a7e69404c0f68aa2e313ea57a0dc053d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#a7e69404c0f68aa2e313ea57a0dc053d6">unordered_set</a> = boost::unordered_set&lt; Key, Hash, KeyEqual, Allocator &gt;</td></tr>
<tr class="memdesc:a7e69404c0f68aa2e313ea57a0dc053d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unordered_set container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#a7e69404c0f68aa2e313ea57a0dc053d6">More...</a><br /></td></tr>
<tr class="separator:a7e69404c0f68aa2e313ea57a0dc053d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09b8143943f9ac654c0a29029a89652"><td class="memTemplParams" colspan="2">template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:ac09b8143943f9ac654c0a29029a89652"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ac09b8143943f9ac654c0a29029a89652">unordered_multiset</a> = boost::unordered_multiset&lt; Key, Hash, KeyEqual, Allocator &gt;</td></tr>
<tr class="memdesc:ac09b8143943f9ac654c0a29029a89652"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unordered_multiset container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ac09b8143943f9ac654c0a29029a89652">More...</a><br /></td></tr>
<tr class="separator:ac09b8143943f9ac654c0a29029a89652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab652095363b8ca308d2d39c53fe6e6ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ab652095363b8ca308d2d39c53fe6e6ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemetall_1_1container.html#ab652095363b8ca308d2d39c53fe6e6ae">vector</a> = boost::container::vector&lt; T, Allocator &gt;</td></tr>
<tr class="memdesc:ab652095363b8ca308d2d39c53fe6e6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector container that uses Metall as its default allocator.  <a href="namespacemetall_1_1container.html#ab652095363b8ca308d2d39c53fe6e6ae">More...</a><br /></td></tr>
<tr class="separator:ab652095363b8ca308d2d39c53fe6e6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for Metall container. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0c5339ff4df05c5ccbfef46f75bf7f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5339ff4df05c5ccbfef46f75bf7f0a">&#9670;&nbsp;</a></span>deque</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a0c5339ff4df05c5ccbfef46f75bf7f0a">metall::container::deque</a> = typedef boost::container::deque&lt;T, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deque container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="metall_containers_8cpp-example.html#a2">metall_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aec6753db897489a2197ff3c693a04396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6753db897489a2197ff3c693a04396">&#9670;&nbsp;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#aec6753db897489a2197ff3c693a04396">metall::container::list</a> = typedef boost::container::list&lt;T, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="ad30d7aceb6d1ba8ab22971a4baf10621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30d7aceb6d1ba8ab22971a4baf10621">&#9670;&nbsp;</a></span>map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ad30d7aceb6d1ba8ab22971a4baf10621">metall::container::map</a> = typedef boost::container::map&lt;Key, T, Compare, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_map_8cpp-example.html#a2">string_map.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae2cd99e1d3323b5f5ee7f57e1a19e1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cd99e1d3323b5f5ee7f57e1a19e1a4">&#9670;&nbsp;</a></span>multimap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ae2cd99e1d3323b5f5ee7f57e1a19e1a4">metall::container::multimap</a> = typedef boost::container::multimap&lt;Key, T, Compare, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multimap container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="a2fede91b4f95ac641e5d38ff6d2e1f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fede91b4f95ac641e5d38ff6d2e1f54">&#9670;&nbsp;</a></span>priority_queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = vector&lt;T&gt;, typename Compare  = std::less&lt;typename Container::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a2fede91b4f95ac641e5d38ff6d2e1f54">metall::container::priority_queue</a> = typedef std::priority_queue&lt;T, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A priority_queue container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="ac4ebbafd91c00bc0bf0db55a75a5c091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ebbafd91c00bc0bf0db55a75a5c091">&#9670;&nbsp;</a></span>queue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ac4ebbafd91c00bc0bf0db55a75a5c091">metall::container::queue</a> = typedef std::queue&lt;T, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="aece4cdd0d20737ad97bb9fccac276bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece4cdd0d20737ad97bb9fccac276bc5">&#9670;&nbsp;</a></span>scoped_allocator_adaptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OuterAlloc , class... InnerAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">metall::container::scoped_allocator_adaptor</a> = typedef boost::container::scoped_allocator_adaptor&lt;OuterAlloc, InnerAlloc...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An allocator which can be used with multilevel containers. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="complex_map_8cpp-example.html#a0">complex_map.cpp</a>, and <a class="el" href="multilevel_containers_8cpp-example.html#a3">multilevel_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a94b644504f948016762c0d431162ab10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b644504f948016762c0d431162ab10">&#9670;&nbsp;</a></span>set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a94b644504f948016762c0d431162ab10">metall::container::set</a> = typedef boost::container::set&lt;Key, Compare, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="a1060d4465ba278f23314fac24020f2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1060d4465ba278f23314fac24020f2a8">&#9670;&nbsp;</a></span>multiset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Compare  = std::less&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a1060d4465ba278f23314fac24020f2a8">metall::container::multiset</a> = typedef boost::container::multiset&lt;Key, Compare, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multiset container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="a45d843f18b46802f391c12875aa14f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d843f18b46802f391c12875aa14f2a">&#9670;&nbsp;</a></span>stack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a45d843f18b46802f391c12875aa14f2a">metall::container::stack</a> = typedef std::stack&lt;T, Container&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A stack container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="a5a4de42b06a5ec17815a15504d100745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4de42b06a5ec17815a15504d100745">&#9670;&nbsp;</a></span>basic_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits  = std::char_traits&lt;CharT&gt;, class Allocator  = metall::manager::allocator_type&lt;CharT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">metall::container::basic_string</a> = typedef boost::container::basic_string&lt;CharT, Traits, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a0">string.cpp</a>, and <a class="el" href="string_map_8cpp-example.html#a0">string_map.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5fe499903b179ed596cd8c2bd6892009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe499903b179ed596cd8c2bd6892009">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">metall::container::string</a> = typedef <a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">basic_string</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string container that uses char as its character type and Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="datastore_description_8cpp-example.html#a3">datastore_description.cpp</a>, <a class="el" href="json_create_8cpp-example.html#a1">json_create.cpp</a>, <a class="el" href="object_attribute_8cpp-example.html#a3">object_attribute.cpp</a>, <a class="el" href="object_attribute_api_list_8cpp-example.html#a4">object_attribute_api_list.cpp</a>, and <a class="el" href="snapshot_8cpp-example.html#a1">snapshot.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6efc3f12030cc354af58b94f53d3858c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efc3f12030cc354af58b94f53d3858c">&#9670;&nbsp;</a></span>wstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a6efc3f12030cc354af58b94f53d3858c">metall::container::wstring</a> = typedef <a class="el" href="namespacemetall_1_1container.html#a5a4de42b06a5ec17815a15504d100745">basic_string</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string container that uses wchar_t as its character type and Metall as its default allocator. </p>

</div>
</div>
<a id="ad6538b68ed07639523fd7313e407881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6538b68ed07639523fd7313e407881a">&#9670;&nbsp;</a></span>unordered_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ad6538b68ed07639523fd7313e407881a">metall::container::unordered_map</a> = typedef boost::unordered_map&lt;Key, T, Hash, KeyEqual, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unordered_map container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="multilevel_containers_8cpp-example.html#a1">multilevel_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae46d3b3ceb781a5b55e5070639919a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46d3b3ceb781a5b55e5070639919a02">&#9670;&nbsp;</a></span>unordered_multimap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;std::pair&lt;const Key, T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ae46d3b3ceb781a5b55e5070639919a02">metall::container::unordered_multimap</a> = typedef boost::unordered_multimap&lt;Key, T, Hash, KeyEqual, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unordered_multimap container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="multilevel_containers_8cpp-example.html#a2">multilevel_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7e69404c0f68aa2e313ea57a0dc053d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e69404c0f68aa2e313ea57a0dc053d6">&#9670;&nbsp;</a></span>unordered_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#a7e69404c0f68aa2e313ea57a0dc053d6">metall::container::unordered_set</a> = typedef boost::unordered_set&lt;Key, Hash, KeyEqual, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unordered_set container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="ac09b8143943f9ac654c0a29029a89652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09b8143943f9ac654c0a29029a89652">&#9670;&nbsp;</a></span>unordered_multiset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = manager::allocator_type&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ac09b8143943f9ac654c0a29029a89652">metall::container::unordered_multiset</a> = typedef boost::unordered_multiset&lt;Key, Hash, KeyEqual, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unordered_multiset container that uses Metall as its default allocator. </p>

</div>
</div>
<a id="ab652095363b8ca308d2d39c53fe6e6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab652095363b8ca308d2d39c53fe6e6ae">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = manager::allocator_type&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemetall_1_1container.html#ab652095363b8ca308d2d39c53fe6e6ae">metall::container::vector</a> = typedef boost::container::vector&lt;T, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector container that uses Metall as its default allocator. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="multilevel_containers_8cpp-example.html#a0">multilevel_containers.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemetall.html">metall</a></li><li class="navelem"><a class="el" href="namespacemetall_1_1container.html">container</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
