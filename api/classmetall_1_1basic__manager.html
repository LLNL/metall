<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Metall: metall::basic_manager&lt; chunk_no_type, k_chunk_size &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Metall
   &#160;<span id="projectnumber">v0.15</span>
   </div>
   <div id="projectbrief">Memoryallocatorforpersistentmemory</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmetall_1_1basic__manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmetall_1_1basic__manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">metall::basic_manager&lt; chunk_no_type, k_chunk_size &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generalized Metall manager class.  
 <a href="classmetall_1_1basic__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__manager_8hpp_source.html">/home/runner/work/metall/metall/include/metall/basic_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ceacfb2028bae1618533062ebe02ed5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a> = kernel::manager_kernel&lt; chunk_no_type, k_chunk_size &gt;</td></tr>
<tr class="memdesc:a4ceacfb2028bae1618533062ebe02ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager kernel type.  <a href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">More...</a><br /></td></tr>
<tr class="separator:a4ceacfb2028bae1618533062ebe02ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a9a99b1775cd9eb6f0ca22a5aa8bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af68a9a99b1775cd9eb6f0ca22a5aa8bd">void_pointer</a> = typename manager_kernel_type::void_pointer</td></tr>
<tr class="memdesc:af68a9a99b1775cd9eb6f0ca22a5aa8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void pointer type.  <a href="classmetall_1_1basic__manager.html#af68a9a99b1775cd9eb6f0ca22a5aa8bd">More...</a><br /></td></tr>
<tr class="separator:af68a9a99b1775cd9eb6f0ca22a5aa8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a734b956eabae70adae4a1432f599cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> = typename manager_kernel_type::char_type</td></tr>
<tr class="memdesc:a6a734b956eabae70adae4a1432f599cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char type.  <a href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">More...</a><br /></td></tr>
<tr class="separator:a6a734b956eabae70adae4a1432f599cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bcb1cb53a0c5a33b02ef3f32ca513d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> = typename manager_kernel_type::size_type</td></tr>
<tr class="memdesc:a81bcb1cb53a0c5a33b02ef3f32ca513d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">More...</a><br /></td></tr>
<tr class="separator:a81bcb1cb53a0c5a33b02ef3f32ca513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e36e85d6dabf0c7561fc2a991638036"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3e36e85d6dabf0c7561fc2a991638036">difference_type</a> = typename manager_kernel_type::difference_type</td></tr>
<tr class="memdesc:a3e36e85d6dabf0c7561fc2a991638036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type.  <a href="classmetall_1_1basic__manager.html#a3e36e85d6dabf0c7561fc2a991638036">More...</a><br /></td></tr>
<tr class="separator:a3e36e85d6dabf0c7561fc2a991638036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0ef8e2a0ebcb1555316b2b2dbd8dbb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b0ef8e2a0ebcb1555316b2b2dbd8dbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a> = <a class="el" href="classmetall_1_1stl__allocator.html">stl_allocator</a>&lt; T, <a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a> &gt;</td></tr>
<tr class="memdesc:a1b0ef8e2a0ebcb1555316b2b2dbd8dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <a href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">More...</a><br /></td></tr>
<tr class="separator:a1b0ef8e2a0ebcb1555316b2b2dbd8dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceee754b9e1cc401bccf704e3b8fd83c"><td class="memTemplParams" colspan="2">template&lt;typename OuterT , typename... InnerT&gt; </td></tr>
<tr class="memitem:aceee754b9e1cc401bccf704e3b8fd83c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aceee754b9e1cc401bccf704e3b8fd83c">scoped_allocator_type</a> = <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt; <a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt; OuterT &gt;, <a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt; InnerT &gt;... &gt;</td></tr>
<tr class="memdesc:aceee754b9e1cc401bccf704e3b8fd83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type wrapped by scoped_allocator_adaptor.  <a href="classmetall_1_1basic__manager.html#aceee754b9e1cc401bccf704e3b8fd83c">More...</a><br /></td></tr>
<tr class="separator:aceee754b9e1cc401bccf704e3b8fd83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a112e98756c6950dc0d88d18b70c14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2a112e98756c6950dc0d88d18b70c14"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a> = metall::mtlldetail::named_proxy&lt; <a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a>, T, false &gt;</td></tr>
<tr class="memdesc:ac2a112e98756c6950dc0d88d18b70c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct proxy.  <a href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">More...</a><br /></td></tr>
<tr class="separator:ac2a112e98756c6950dc0d88d18b70c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf749c86b4771dcf828d44d8ab41d000"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf749c86b4771dcf828d44d8ab41d000"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a> = metall::mtlldetail::named_proxy&lt; <a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a>, T, true &gt;</td></tr>
<tr class="memdesc:abf749c86b4771dcf828d44d8ab41d000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator proxy.  <a href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">More...</a><br /></td></tr>
<tr class="separator:abf749c86b4771dcf828d44d8ab41d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6a68e50275402ecf183c8ad00bc29"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">instance_kind</a> = typename manager_kernel_type::instance_kind</td></tr>
<tr class="memdesc:a2bb6a68e50275402ecf183c8ad00bc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">An value that describes the type of the instance constructed in memory.  <a href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">More...</a><br /></td></tr>
<tr class="separator:a2bb6a68e50275402ecf183c8ad00bc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748fe63e04d58cedb365d17f84c2e1ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a> = typename manager_kernel_type::const_named_iterator</td></tr>
<tr class="memdesc:a748fe63e04d58cedb365d17f84c2e1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for named objects.  <a href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">More...</a><br /></td></tr>
<tr class="separator:a748fe63e04d58cedb365d17f84c2e1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac7b6423046445a8aa58b3d8d267720"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a> = typename manager_kernel_type::const_unique_iterator</td></tr>
<tr class="memdesc:a6ac7b6423046445a8aa58b3d8d267720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for unique objects.  <a href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">More...</a><br /></td></tr>
<tr class="separator:a6ac7b6423046445a8aa58b3d8d267720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe466a3ab9fc8a6ad32ebe29deeafee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a> = typename manager_kernel_type::const_anonymous_iterator</td></tr>
<tr class="memdesc:aafe466a3ab9fc8a6ad32ebe29deeafee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for anonymous objects.  <a href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">More...</a><br /></td></tr>
<tr class="separator:aafe466a3ab9fc8a6ad32ebe29deeafee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82455b70cbf57c44cbe0a0e1957dd3e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a82455b70cbf57c44cbe0a0e1957dd3e1">named_object_attribute_accessor_type</a> = typename manager_kernel_type::named_object_attr_accessor_type</td></tr>
<tr class="memdesc:a82455b70cbf57c44cbe0a0e1957dd3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to named object attribute.  <a href="classmetall_1_1basic__manager.html#a82455b70cbf57c44cbe0a0e1957dd3e1">More...</a><br /></td></tr>
<tr class="separator:a82455b70cbf57c44cbe0a0e1957dd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd2592146b8a4737e22e4fd21fa1e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af4cd2592146b8a4737e22e4fd21fa1e2">unique_object_attribute_accessor_type</a> = typename manager_kernel_type::unique_object_attr_accessor_type</td></tr>
<tr class="memdesc:af4cd2592146b8a4737e22e4fd21fa1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to unique object attribute.  <a href="classmetall_1_1basic__manager.html#af4cd2592146b8a4737e22e4fd21fa1e2">More...</a><br /></td></tr>
<tr class="separator:af4cd2592146b8a4737e22e4fd21fa1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ee47c700b22b2b0320e225f95e824"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a570ee47c700b22b2b0320e225f95e824">anonymous_object_attribute_accessor_type</a> = typename manager_kernel_type::anonymous_object_attr_accessor_type</td></tr>
<tr class="memdesc:a570ee47c700b22b2b0320e225f95e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to anonymous object attribute.  <a href="classmetall_1_1basic__manager.html#a570ee47c700b22b2b0320e225f95e824">More...</a><br /></td></tr>
<tr class="separator:a570ee47c700b22b2b0320e225f95e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372b54cc19bad9c79e3b397f997bf8f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a372b54cc19bad9c79e3b397f997bf8f2">chunk_number_type</a> = chunk_no_type</td></tr>
<tr class="memdesc:a372b54cc19bad9c79e3b397f997bf8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunk number type (= chunk_no_type)  <a href="classmetall_1_1basic__manager.html#a372b54cc19bad9c79e3b397f997bf8f2">More...</a><br /></td></tr>
<tr class="separator:a372b54cc19bad9c79e3b397f997bf8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afff9d2fe24574ba43db2e0df21fd5492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#afff9d2fe24574ba43db2e0df21fd5492">basic_manager</a> (<a class="el" href="structmetall_1_1open__only__t.html">open_only_t</a>, const char *base_path) noexcept</td></tr>
<tr class="memdesc:afff9d2fe24574ba43db2e0df21fd5492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing data store.  <a href="classmetall_1_1basic__manager.html#afff9d2fe24574ba43db2e0df21fd5492">More...</a><br /></td></tr>
<tr class="separator:afff9d2fe24574ba43db2e0df21fd5492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a2c3ddf07bdffe3d07d653a88af080"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac0a2c3ddf07bdffe3d07d653a88af080">basic_manager</a> (<a class="el" href="structmetall_1_1open__read__only__t.html">open_read_only_t</a>, const char *base_path) noexcept</td></tr>
<tr class="memdesc:ac0a2c3ddf07bdffe3d07d653a88af080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing data store with the read only mode. Write accesses will cause segmentation fault.  <a href="classmetall_1_1basic__manager.html#ac0a2c3ddf07bdffe3d07d653a88af080">More...</a><br /></td></tr>
<tr class="separator:ac0a2c3ddf07bdffe3d07d653a88af080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d636fd6aae55366338cf7afd32f1d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1d636fd6aae55366338cf7afd32f1d5e">basic_manager</a> (<a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>, const char *base_path) noexcept</td></tr>
<tr class="memdesc:a1d636fd6aae55366338cf7afd32f1d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new data store (an existing data store will be overwritten).  <a href="classmetall_1_1basic__manager.html#a1d636fd6aae55366338cf7afd32f1d5e">More...</a><br /></td></tr>
<tr class="separator:a1d636fd6aae55366338cf7afd32f1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c19e2c19d114cb0820c4777769f23af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6c19e2c19d114cb0820c4777769f23af">basic_manager</a> (<a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>, const char *base_path, const <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> capacity) noexcept</td></tr>
<tr class="memdesc:a6c19e2c19d114cb0820c4777769f23af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new data store (an existing data store will be overwritten).  <a href="classmetall_1_1basic__manager.html#a6c19e2c19d114cb0820c4777769f23af">More...</a><br /></td></tr>
<tr class="separator:a6c19e2c19d114cb0820c4777769f23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6da3d6be384f15482f90673c67007e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a> ()=delete</td></tr>
<tr class="memdesc:aeb6da3d6be384f15482f90673c67007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">More...</a><br /></td></tr>
<tr class="separator:aeb6da3d6be384f15482f90673c67007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa9cfc8bb26f7624c4a5683cec2e6f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a8aa9cfc8bb26f7624c4a5683cec2e6f6">~basic_manager</a> () noexcept=default</td></tr>
<tr class="memdesc:a8aa9cfc8bb26f7624c4a5683cec2e6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classmetall_1_1basic__manager.html#a8aa9cfc8bb26f7624c4a5683cec2e6f6">More...</a><br /></td></tr>
<tr class="separator:a8aa9cfc8bb26f7624c4a5683cec2e6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea252b2d3347f1a29156a536d45385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac1ea252b2d3347f1a29156a536d45385">basic_manager</a> (const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac1ea252b2d3347f1a29156a536d45385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#ac1ea252b2d3347f1a29156a536d45385">More...</a><br /></td></tr>
<tr class="separator:ac1ea252b2d3347f1a29156a536d45385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c259f26f9fe6ab9458f4cbe199177b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3c259f26f9fe6ab9458f4cbe199177b5">basic_manager</a> (<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a3c259f26f9fe6ab9458f4cbe199177b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classmetall_1_1basic__manager.html#a3c259f26f9fe6ab9458f4cbe199177b5">More...</a><br /></td></tr>
<tr class="separator:a3c259f26f9fe6ab9458f4cbe199177b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc065ea6fd0de68de273c6515de7ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a8dc065ea6fd0de68de273c6515de7ee7">operator=</a> (const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;)=delete</td></tr>
<tr class="memdesc:a8dc065ea6fd0de68de273c6515de7ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#a8dc065ea6fd0de68de273c6515de7ee7">More...</a><br /></td></tr>
<tr class="separator:a8dc065ea6fd0de68de273c6515de7ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee4e322b3282f069c20e8e86bf8685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a7aee4e322b3282f069c20e8e86bf8685">operator=</a> (<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a7aee4e322b3282f069c20e8e86bf8685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classmetall_1_1basic__manager.html#a7aee4e322b3282f069c20e8e86bf8685">More...</a><br /></td></tr>
<tr class="separator:a7aee4e322b3282f069c20e8e86bf8685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5969e8d2fb5cd08117b3997b01e43154"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5969e8d2fb5cd08117b3997b01e43154"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5969e8d2fb5cd08117b3997b01e43154">construct</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a5969e8d2fb5cd08117b3997b01e43154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object of type T.  <a href="classmetall_1_1basic__manager.html#a5969e8d2fb5cd08117b3997b01e43154">More...</a><br /></td></tr>
<tr class="separator:a5969e8d2fb5cd08117b3997b01e43154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef134b01c3d3870e18900b0d5d45125"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ef134b01c3d3870e18900b0d5d45125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5ef134b01c3d3870e18900b0d5d45125">find_or_construct</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a5ef134b01c3d3870e18900b0d5d45125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an already constructed object. If not exist, constructs an object of type T.  <a href="classmetall_1_1basic__manager.html#a5ef134b01c3d3870e18900b0d5d45125">More...</a><br /></td></tr>
<tr class="separator:a5ef134b01c3d3870e18900b0d5d45125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2d815b2bebb6fbb2995fedd586074f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf2d815b2bebb6fbb2995fedd586074f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#abf2d815b2bebb6fbb2995fedd586074f">construct_it</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:abf2d815b2bebb6fbb2995fedd586074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array of objects of type T, receiving arguments from iterators.  <a href="classmetall_1_1basic__manager.html#abf2d815b2bebb6fbb2995fedd586074f">More...</a><br /></td></tr>
<tr class="separator:abf2d815b2bebb6fbb2995fedd586074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed20085551d94d4afb0b90a261c6999"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeed20085551d94d4afb0b90a261c6999"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aeed20085551d94d4afb0b90a261c6999">find_or_construct_it</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:aeed20085551d94d4afb0b90a261c6999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an already constructed object. If not exist, constructs an array of objects of type T, receiving arguments from iterators.  <a href="classmetall_1_1basic__manager.html#aeed20085551d94d4afb0b90a261c6999">More...</a><br /></td></tr>
<tr class="separator:aeed20085551d94d4afb0b90a261c6999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754b815d4f0186d01c45d736dbf4f6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9754b815d4f0186d01c45d736dbf4f6b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9754b815d4f0186d01c45d736dbf4f6b">find</a> (char_ptr_holder_type name) const noexcept</td></tr>
<tr class="memdesc:a9754b815d4f0186d01c45d736dbf4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a previously created object.  <a href="classmetall_1_1basic__manager.html#a9754b815d4f0186d01c45d736dbf4f6b">More...</a><br /></td></tr>
<tr class="separator:a9754b815d4f0186d01c45d736dbf4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6198d2ec97fbd605f249123cebdef09f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6198d2ec97fbd605f249123cebdef09f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6198d2ec97fbd605f249123cebdef09f">destroy</a> (const char *name)</td></tr>
<tr class="memdesc:a6198d2ec97fbd605f249123cebdef09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a previously created object. Calls the destructor and frees the memory.  <a href="classmetall_1_1basic__manager.html#a6198d2ec97fbd605f249123cebdef09f">More...</a><br /></td></tr>
<tr class="separator:a6198d2ec97fbd605f249123cebdef09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b07fec3f2a459967ebfa7499f57d91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7b07fec3f2a459967ebfa7499f57d91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aa7b07fec3f2a459967ebfa7499f57d91">destroy</a> (const metall::mtlldetail::unique_instance_t *const)</td></tr>
<tr class="memdesc:aa7b07fec3f2a459967ebfa7499f57d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a unique object of type T. Calls the destructor and frees the memory.  <a href="classmetall_1_1basic__manager.html#aa7b07fec3f2a459967ebfa7499f57d91">More...</a><br /></td></tr>
<tr class="separator:aa7b07fec3f2a459967ebfa7499f57d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414147f5df62113d7a544647eb88135"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5414147f5df62113d7a544647eb88135"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5414147f5df62113d7a544647eb88135">destroy_ptr</a> (const T *ptr)</td></tr>
<tr class="memdesc:a5414147f5df62113d7a544647eb88135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a object (named, unique, or anonymous) by its address. Calls the destructor and frees the memory. Cannot destroy an object not allocated by construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#a5414147f5df62113d7a544647eb88135">More...</a><br /></td></tr>
<tr class="separator:a5414147f5df62113d7a544647eb88135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204164d125dc38d1468476ecf208c4da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a204164d125dc38d1468476ecf208c4da"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a204164d125dc38d1468476ecf208c4da">get_instance_name</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:a204164d125dc38d1468476ecf208c4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an object created with construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#a204164d125dc38d1468476ecf208c4da">More...</a><br /></td></tr>
<tr class="separator:a204164d125dc38d1468476ecf208c4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81c86f7aaa1c1a174fd579a495830e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac81c86f7aaa1c1a174fd579a495830e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">instance_kind</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac81c86f7aaa1c1a174fd579a495830e7">get_instance_kind</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:ac81c86f7aaa1c1a174fd579a495830e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of an object created with construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#ac81c86f7aaa1c1a174fd579a495830e7">More...</a><br /></td></tr>
<tr class="separator:ac81c86f7aaa1c1a174fd579a495830e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f9ee419d5ed745d889b676758d5e1b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2f9ee419d5ed745d889b676758d5e1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ae2f9ee419d5ed745d889b676758d5e1b">get_instance_length</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:ae2f9ee419d5ed745d889b676758d5e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of an object created with construct/find_or_construct functions (1 if is a single element, &gt;=1 if it's an array).  <a href="classmetall_1_1basic__manager.html#ae2f9ee419d5ed745d889b676758d5e1b">More...</a><br /></td></tr>
<tr class="separator:ae2f9ee419d5ed745d889b676758d5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae227081782b1357e180f1b5e5e70a5e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aae227081782b1357e180f1b5e5e70a5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aae227081782b1357e180f1b5e5e70a5e">is_instance_type</a> (const void *const ptr) const noexcept</td></tr>
<tr class="memdesc:aae227081782b1357e180f1b5e5e70a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the type of an object, which was created with construct/find_or_construct functions, is T.  <a href="classmetall_1_1basic__manager.html#aae227081782b1357e180f1b5e5e70a5e">More...</a><br /></td></tr>
<tr class="separator:aae227081782b1357e180f1b5e5e70a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79657e540e426fe8494595fc29125a14"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a79657e540e426fe8494595fc29125a14"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a79657e540e426fe8494595fc29125a14">get_instance_description</a> (const T *ptr, std::string *description) const noexcept</td></tr>
<tr class="memdesc:a79657e540e426fe8494595fc29125a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the description of an object created with construct/find_or_construct.  <a href="classmetall_1_1basic__manager.html#a79657e540e426fe8494595fc29125a14">More...</a><br /></td></tr>
<tr class="separator:a79657e540e426fe8494595fc29125a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa7a3ceca561100d782dd867260c31a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1fa7a3ceca561100d782dd867260c31a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1fa7a3ceca561100d782dd867260c31a">set_instance_description</a> (const T *ptr, const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:a1fa7a3ceca561100d782dd867260c31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to an object created with construct/find_or_construct.  <a href="classmetall_1_1basic__manager.html#a1fa7a3ceca561100d782dd867260c31a">More...</a><br /></td></tr>
<tr class="separator:a1fa7a3ceca561100d782dd867260c31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2ec162eae5499c41b897ba4debf61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a0b2ec162eae5499c41b897ba4debf61d">get_num_named_objects</a> () const noexcept</td></tr>
<tr class="memdesc:a0b2ec162eae5499c41b897ba4debf61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of named objects stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#a0b2ec162eae5499c41b897ba4debf61d">More...</a><br /></td></tr>
<tr class="separator:a0b2ec162eae5499c41b897ba4debf61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa814b3cf538ccb15b5a4ca3a820c775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aaa814b3cf538ccb15b5a4ca3a820c775">get_num_unique_objects</a> () const noexcept</td></tr>
<tr class="memdesc:aaa814b3cf538ccb15b5a4ca3a820c775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of unique objects stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#aaa814b3cf538ccb15b5a4ca3a820c775">More...</a><br /></td></tr>
<tr class="separator:aaa814b3cf538ccb15b5a4ca3a820c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55910f75d630b6d82382a5f542b07e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a55910f75d630b6d82382a5f542b07e8f">get_num_anonymous_objects</a> () const noexcept</td></tr>
<tr class="memdesc:a55910f75d630b6d82382a5f542b07e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of anonymous objects (objects constructed with metall::anonymous_instance) stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#a55910f75d630b6d82382a5f542b07e8f">More...</a><br /></td></tr>
<tr class="separator:a55910f75d630b6d82382a5f542b07e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e2244acc4b5665c49629889d87936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ae13e2244acc4b5665c49629889d87936">named_begin</a> () const noexcept</td></tr>
<tr class="memdesc:ae13e2244acc4b5665c49629889d87936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the named objects.  <a href="classmetall_1_1basic__manager.html#ae13e2244acc4b5665c49629889d87936">More...</a><br /></td></tr>
<tr class="separator:ae13e2244acc4b5665c49629889d87936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23d6c0aafb56d7a89a031b86a7355e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ae23d6c0aafb56d7a89a031b86a7355e8">named_end</a> () const noexcept</td></tr>
<tr class="memdesc:ae23d6c0aafb56d7a89a031b86a7355e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the named allocations.  <a href="classmetall_1_1basic__manager.html#ae23d6c0aafb56d7a89a031b86a7355e8">More...</a><br /></td></tr>
<tr class="separator:ae23d6c0aafb56d7a89a031b86a7355e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad246a8d9ecd8f6f468a186fb97f6f5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ad246a8d9ecd8f6f468a186fb97f6f5b3">unique_begin</a> () const noexcept</td></tr>
<tr class="memdesc:ad246a8d9ecd8f6f468a186fb97f6f5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the unique objects.  <a href="classmetall_1_1basic__manager.html#ad246a8d9ecd8f6f468a186fb97f6f5b3">More...</a><br /></td></tr>
<tr class="separator:ad246a8d9ecd8f6f468a186fb97f6f5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f5e9425c520764d43c9afaea4cf732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a85f5e9425c520764d43c9afaea4cf732">unique_end</a> () const noexcept</td></tr>
<tr class="memdesc:a85f5e9425c520764d43c9afaea4cf732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the unique allocations. NOT thread-safe. Never throws.  <a href="classmetall_1_1basic__manager.html#a85f5e9425c520764d43c9afaea4cf732">More...</a><br /></td></tr>
<tr class="separator:a85f5e9425c520764d43c9afaea4cf732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d110ce0188fbe9e1ff573419b8710e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a56d110ce0188fbe9e1ff573419b8710e">anonymous_begin</a> () const noexcept</td></tr>
<tr class="memdesc:a56d110ce0188fbe9e1ff573419b8710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the anonymous objects.  <a href="classmetall_1_1basic__manager.html#a56d110ce0188fbe9e1ff573419b8710e">More...</a><br /></td></tr>
<tr class="separator:a56d110ce0188fbe9e1ff573419b8710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a3b3de6dfd6ed06fd6a1e9a5e0c021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a41a3b3de6dfd6ed06fd6a1e9a5e0c021">anonymous_end</a> () const noexcept</td></tr>
<tr class="memdesc:a41a3b3de6dfd6ed06fd6a1e9a5e0c021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the anonymous allocations. NOT thread-safe. Never throws.  <a href="classmetall_1_1basic__manager.html#a41a3b3de6dfd6ed06fd6a1e9a5e0c021">More...</a><br /></td></tr>
<tr class="separator:a41a3b3de6dfd6ed06fd6a1e9a5e0c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86580eab94bcf8aa5a7aeeff13bc97df"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a86580eab94bcf8aa5a7aeeff13bc97df">allocate</a> (<a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> nbytes) noexcept</td></tr>
<tr class="memdesc:a86580eab94bcf8aa5a7aeeff13bc97df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates nbytes bytes.  <a href="classmetall_1_1basic__manager.html#a86580eab94bcf8aa5a7aeeff13bc97df">More...</a><br /></td></tr>
<tr class="separator:a86580eab94bcf8aa5a7aeeff13bc97df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44fd6015d396865866ee627448acab0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ae44fd6015d396865866ee627448acab0">allocate_aligned</a> (<a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> nbytes, <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> alignment) noexcept</td></tr>
<tr class="memdesc:ae44fd6015d396865866ee627448acab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates nbytes bytes. The address of the allocated memory will be a multiple of alignment.  <a href="classmetall_1_1basic__manager.html#ae44fd6015d396865866ee627448acab0">More...</a><br /></td></tr>
<tr class="separator:ae44fd6015d396865866ee627448acab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e71f9e005a4c87d0de9bc55df9db3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4e71f9e005a4c87d0de9bc55df9db3b0">deallocate</a> (void *addr) noexcept</td></tr>
<tr class="memdesc:a4e71f9e005a4c87d0de9bc55df9db3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the allocated memory.  <a href="classmetall_1_1basic__manager.html#a4e71f9e005a4c87d0de9bc55df9db3b0">More...</a><br /></td></tr>
<tr class="separator:a4e71f9e005a4c87d0de9bc55df9db3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d2ee578e6de1fdbc5f541657cfb6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a57d2ee578e6de1fdbc5f541657cfb6b0">flush</a> (const bool synchronous=true) noexcept</td></tr>
<tr class="memdesc:a57d2ee578e6de1fdbc5f541657cfb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush data to persistent memory.  <a href="classmetall_1_1basic__manager.html#a57d2ee578e6de1fdbc5f541657cfb6b0">More...</a><br /></td></tr>
<tr class="separator:a57d2ee578e6de1fdbc5f541657cfb6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116d586f8c86b04c355953f5efc3264"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9116d586f8c86b04c355953f5efc3264">snapshot</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *destination_dir_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:a9116d586f8c86b04c355953f5efc3264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a snapshot of the current data. The snapshot has a new UUID.  <a href="classmetall_1_1basic__manager.html#a9116d586f8c86b04c355953f5efc3264">More...</a><br /></td></tr>
<tr class="separator:a9116d586f8c86b04c355953f5efc3264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c017dfee8914fcd0916d70b7b765357"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5c017dfee8914fcd0916d70b7b765357">get_uuid</a> () const noexcept</td></tr>
<tr class="memdesc:a5c017dfee8914fcd0916d70b7b765357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID of the data store.  <a href="classmetall_1_1basic__manager.html#a5c017dfee8914fcd0916d70b7b765357">More...</a><br /></td></tr>
<tr class="separator:a5c017dfee8914fcd0916d70b7b765357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e05b27dc7c5b0d11a6e08b9bd23311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a77e05b27dc7c5b0d11a6e08b9bd23311">get_version</a> () const noexcept</td></tr>
<tr class="memdesc:a77e05b27dc7c5b0d11a6e08b9bd23311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version of the Metall that created the backing data store.  <a href="classmetall_1_1basic__manager.html#a77e05b27dc7c5b0d11a6e08b9bd23311">More...</a><br /></td></tr>
<tr class="separator:a77e05b27dc7c5b0d11a6e08b9bd23311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412da2f484c6d5246541ee5b874de9d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a412da2f484c6d5246541ee5b874de9d1">set_description</a> (const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:a412da2f484c6d5246541ee5b874de9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to a Metall data store. An existing description is overwritten (only one description per data store).  <a href="classmetall_1_1basic__manager.html#a412da2f484c6d5246541ee5b874de9d1">More...</a><br /></td></tr>
<tr class="separator:a412da2f484c6d5246541ee5b874de9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2d7866d60dd88791fd78119fa09562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2e2d7866d60dd88791fd78119fa09562">get_description</a> (std::string *description) const noexcept</td></tr>
<tr class="memdesc:a2e2d7866d60dd88791fd78119fa09562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a description. If there is no description, nothing to happen to the given description object.  <a href="classmetall_1_1basic__manager.html#a2e2d7866d60dd88791fd78119fa09562">More...</a><br /></td></tr>
<tr class="separator:a2e2d7866d60dd88791fd78119fa09562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7017ce2a65fbfd7840d83d5e596e4b9"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::byte&gt; </td></tr>
<tr class="memitem:ad7017ce2a65fbfd7840d83d5e596e4b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ad7017ce2a65fbfd7840d83d5e596e4b9">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ad7017ce2a65fbfd7840d83d5e596e4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a STL compatible allocator object.  <a href="classmetall_1_1basic__manager.html#ad7017ce2a65fbfd7840d83d5e596e4b9">More...</a><br /></td></tr>
<tr class="separator:ad7017ce2a65fbfd7840d83d5e596e4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0630bdfbda0fa676f288c2c63a1c3be"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af0630bdfbda0fa676f288c2c63a1c3be">get_address</a> () const noexcept</td></tr>
<tr class="memdesc:af0630bdfbda0fa676f288c2c63a1c3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the application data segment.  <a href="classmetall_1_1basic__manager.html#af0630bdfbda0fa676f288c2c63a1c3be">More...</a><br /></td></tr>
<tr class="separator:af0630bdfbda0fa676f288c2c63a1c3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa2f79e199ec2be2f6da179802a6485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5fa2f79e199ec2be2f6da179802a6485">get_size</a> () const noexcept</td></tr>
<tr class="memdesc:a5fa2f79e199ec2be2f6da179802a6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (i.e., the maximum total allocation size) of the application data segment. This is a theoretical value. The actual total allocation size Metall can handle will be less than that.  <a href="classmetall_1_1basic__manager.html#a5fa2f79e199ec2be2f6da179802a6485">More...</a><br /></td></tr>
<tr class="separator:a5fa2f79e199ec2be2f6da179802a6485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ad0f6a040457a73e9d9f0dc41ce797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a38ad0f6a040457a73e9d9f0dc41ce797">check_sanity</a> () const noexcept</td></tr>
<tr class="separator:a38ad0f6a040457a73e9d9f0dc41ce797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab721ac4255db8300c2dbcfc0686ec108"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab721ac4255db8300c2dbcfc0686ec108">copy</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *source_dir_path, const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *destination_dir_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:ab721ac4255db8300c2dbcfc0686ec108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data store synchronously. The behavior of copying a data store that is open without the read-only mode is undefined.  <a href="classmetall_1_1basic__manager.html#ab721ac4255db8300c2dbcfc0686ec108">More...</a><br /></td></tr>
<tr class="separator:ab721ac4255db8300c2dbcfc0686ec108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83098558d6f2dbe4892071b345bf10"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aba83098558d6f2dbe4892071b345bf10">copy_async</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *source_dir_path, const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *destination_dir_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:aba83098558d6f2dbe4892071b345bf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data store asynchronously. The behavior of copying a data store that is open without the read-only mode is undefined.  <a href="classmetall_1_1basic__manager.html#aba83098558d6f2dbe4892071b345bf10">More...</a><br /></td></tr>
<tr class="separator:aba83098558d6f2dbe4892071b345bf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad76e66a54b5d32a323949321603173"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3ad76e66a54b5d32a323949321603173">remove</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *dir_path) noexcept</td></tr>
<tr class="memdesc:a3ad76e66a54b5d32a323949321603173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data store synchronously.  <a href="classmetall_1_1basic__manager.html#a3ad76e66a54b5d32a323949321603173">More...</a><br /></td></tr>
<tr class="separator:a3ad76e66a54b5d32a323949321603173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515e65f2375a5b75f6b96e774c45f45"><td class="memItemLeft" align="right" valign="top">static std::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a8515e65f2375a5b75f6b96e774c45f45">remove_async</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *dir_path) noexcept</td></tr>
<tr class="memdesc:a8515e65f2375a5b75f6b96e774c45f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove data store asynchronously.  <a href="classmetall_1_1basic__manager.html#a8515e65f2375a5b75f6b96e774c45f45">More...</a><br /></td></tr>
<tr class="separator:a8515e65f2375a5b75f6b96e774c45f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7c87f6f553405e86eb4221e1972b44"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#acf7c87f6f553405e86eb4221e1972b44">consistent</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *dir_path) noexcept</td></tr>
<tr class="memdesc:acf7c87f6f553405e86eb4221e1972b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a data store exists and is consistent (i.e., it was closed properly in the previous run).  <a href="classmetall_1_1basic__manager.html#acf7c87f6f553405e86eb4221e1972b44">More...</a><br /></td></tr>
<tr class="separator:acf7c87f6f553405e86eb4221e1972b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c454555ec0e5cfbdbbfb59c84b842c2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1c454555ec0e5cfbdbbfb59c84b842c2">get_uuid</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *dir_path) noexcept</td></tr>
<tr class="memdesc:a1c454555ec0e5cfbdbbfb59c84b842c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID of the data store.  <a href="classmetall_1_1basic__manager.html#a1c454555ec0e5cfbdbbfb59c84b842c2">More...</a><br /></td></tr>
<tr class="separator:a1c454555ec0e5cfbdbbfb59c84b842c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4610e0a74c12b9c5dfc4afe843dcf67c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4610e0a74c12b9c5dfc4afe843dcf67c">get_version</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *dir_path) noexcept</td></tr>
<tr class="memdesc:a4610e0a74c12b9c5dfc4afe843dcf67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version of the Metall that created the backing data store.  <a href="classmetall_1_1basic__manager.html#a4610e0a74c12b9c5dfc4afe843dcf67c">More...</a><br /></td></tr>
<tr class="separator:a4610e0a74c12b9c5dfc4afe843dcf67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab938a60344e09a64d36b5c85cedef572"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab938a60344e09a64d36b5c85cedef572">set_description</a> (const char *dir_path, const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:ab938a60344e09a64d36b5c85cedef572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to a Metall data store. An existing description is overwritten (only one description per data store).  <a href="classmetall_1_1basic__manager.html#ab938a60344e09a64d36b5c85cedef572">More...</a><br /></td></tr>
<tr class="separator:ab938a60344e09a64d36b5c85cedef572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e1fc534e424ae1e76e16e1a176e9d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a7a2e1fc534e424ae1e76e16e1a176e9d">get_description</a> (const char *dir_path, std::string *description) noexcept</td></tr>
<tr class="memdesc:a7a2e1fc534e424ae1e76e16e1a176e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a description. If there is no description, nothing to happen to the given description object.  <a href="classmetall_1_1basic__manager.html#a7a2e1fc534e424ae1e76e16e1a176e9d">More...</a><br /></td></tr>
<tr class="separator:a7a2e1fc534e424ae1e76e16e1a176e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb6c05e33ba6f3c946d22f2d3156778"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#a82455b70cbf57c44cbe0a0e1957dd3e1">named_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5fb6c05e33ba6f3c946d22f2d3156778">access_named_object_attribute</a> (const char *dir_path) noexcept</td></tr>
<tr class="memdesc:a5fb6c05e33ba6f3c946d22f2d3156778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of named objects.  <a href="classmetall_1_1basic__manager.html#a5fb6c05e33ba6f3c946d22f2d3156778">More...</a><br /></td></tr>
<tr class="separator:a5fb6c05e33ba6f3c946d22f2d3156778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641acc514ae2f485511ba4b7be4cc320"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#af4cd2592146b8a4737e22e4fd21fa1e2">unique_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a641acc514ae2f485511ba4b7be4cc320">access_unique_object_attribute</a> (const char *dir_path) noexcept</td></tr>
<tr class="memdesc:a641acc514ae2f485511ba4b7be4cc320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of unique object.  <a href="classmetall_1_1basic__manager.html#a641acc514ae2f485511ba4b7be4cc320">More...</a><br /></td></tr>
<tr class="separator:a641acc514ae2f485511ba4b7be4cc320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84077c8ae012c4c4dd644c000e36a8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#a570ee47c700b22b2b0320e225f95e824">anonymous_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3e84077c8ae012c4c4dd644c000e36a8">access_anonymous_object_attribute</a> (const char *dir_path) noexcept</td></tr>
<tr class="memdesc:a3e84077c8ae012c4c4dd644c000e36a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of anonymous object.  <a href="classmetall_1_1basic__manager.html#a3e84077c8ae012c4c4dd644c000e36a8">More...</a><br /></td></tr>
<tr class="separator:a3e84077c8ae012c4c4dd644c000e36a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669faef5d9504e7c7f8aa0337b29f506"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a669faef5d9504e7c7f8aa0337b29f506">chunk_size</a> () noexcept</td></tr>
<tr class="memdesc:a669faef5d9504e7c7f8aa0337b29f506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal chunk size.  <a href="classmetall_1_1basic__manager.html#a669faef5d9504e7c7f8aa0337b29f506">More...</a><br /></td></tr>
<tr class="separator:a669faef5d9504e7c7f8aa0337b29f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename chunk_no_type = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt;<br />
class metall::basic_manager&lt; chunk_no_type, k_chunk_size &gt;</h3>

<p>A generalized Metall manager class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">chunk_no_type</td><td></td></tr>
    <tr><td class="paramname">k_chunk_size</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adjacency_list_graph_8cpp-example.html#_a2">adjacency_list_graph.cpp</a>, <a class="el" href="complex_map_8cpp-example.html#_a2">complex_map.cpp</a>, <a class="el" href="concurrent_map_8cpp-example.html#_a3">concurrent_map.cpp</a>, <a class="el" href="csr_graph_8cpp-example.html#_a3">csr_graph.cpp</a>, <a class="el" href="datastore_description_8cpp-example.html#_a1">datastore_description.cpp</a>, <a class="el" href="fallback_allocator_adaptor_8cpp-example.html#_a2">fallback_allocator_adaptor.cpp</a>, <a class="el" href="jgraph_8cpp-example.html#_a3">jgraph.cpp</a>, <a class="el" href="json_create_8cpp-example.html#_a3">json_create.cpp</a>, <a class="el" href="json_open_8cpp-example.html#_a2">json_open.cpp</a>, <a class="el" href="metall_containers_8cpp-example.html#_a1">metall_containers.cpp</a>, <a class="el" href="multilevel_containers_8cpp-example.html#_a6">multilevel_containers.cpp</a>, <a class="el" href="object_attribute_8cpp-example.html#_a1">object_attribute.cpp</a>, <a class="el" href="object_attribute_api_list_8cpp-example.html#_a2">object_attribute_api_list.cpp</a>, <a class="el" href="offset_pointer_8cpp-example.html#_a1">offset_pointer.cpp</a>, <a class="el" href="simple_8cpp-example.html#_a1">simple.cpp</a>, <a class="el" href="snapshot_8cpp-example.html#_a2">snapshot.cpp</a>, <a class="el" href="string_8cpp-example.html#_a3">string.cpp</a>, <a class="el" href="string_map_8cpp-example.html#_a3">string_map.cpp</a>, and <a class="el" href="vector_of_vectors_8cpp-example.html#_a2">vector_of_vectors.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4ceacfb2028bae1618533062ebe02ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceacfb2028bae1618533062ebe02ed5">&#9670;&nbsp;</a></span>manager_kernel_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a> =  kernel::manager_kernel&lt;chunk_no_type, k_chunk_size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manager kernel type. </p>

</div>
</div>
<a id="af68a9a99b1775cd9eb6f0ca22a5aa8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68a9a99b1775cd9eb6f0ca22a5aa8bd">&#9670;&nbsp;</a></span>void_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#af68a9a99b1775cd9eb6f0ca22a5aa8bd">void_pointer</a> =  typename manager_kernel_type::void_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Void pointer type. </p>

</div>
</div>
<a id="a6a734b956eabae70adae4a1432f599cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a734b956eabae70adae4a1432f599cf">&#9670;&nbsp;</a></span>char_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> =  typename manager_kernel_type::char_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Char type. </p>

</div>
</div>
<a id="a81bcb1cb53a0c5a33b02ef3f32ca513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bcb1cb53a0c5a33b02ef3f32ca513d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> =  typename manager_kernel_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>

</div>
</div>
<a id="a3e36e85d6dabf0c7561fc2a991638036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e36e85d6dabf0c7561fc2a991638036">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a3e36e85d6dabf0c7561fc2a991638036">difference_type</a> =  typename manager_kernel_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type. </p>

</div>
</div>
<a id="a1b0ef8e2a0ebcb1555316b2b2dbd8dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a> =  <a class="el" href="classmetall_1_1stl__allocator.html">stl_allocator</a>&lt;T, <a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

</div>
</div>
<a id="aceee754b9e1cc401bccf704e3b8fd83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceee754b9e1cc401bccf704e3b8fd83c">&#9670;&nbsp;</a></span>scoped_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename OuterT , typename... InnerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#aceee754b9e1cc401bccf704e3b8fd83c">scoped_allocator_type</a> =  <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt;<a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt;OuterT&gt;, <a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt;InnerT&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type wrapped by scoped_allocator_adaptor. </p>

</div>
</div>
<a id="ac2a112e98756c6950dc0d88d18b70c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a112e98756c6950dc0d88d18b70c14">&#9670;&nbsp;</a></span>construct_proxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a> =  metall::mtlldetail::named_proxy&lt;<a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a>, T, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct proxy. </p>

</div>
</div>
<a id="abf749c86b4771dcf828d44d8ab41d000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf749c86b4771dcf828d44d8ab41d000">&#9670;&nbsp;</a></span>construct_iter_proxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a> =  metall::mtlldetail::named_proxy&lt;<a class="el" href="classmetall_1_1basic__manager.html#a4ceacfb2028bae1618533062ebe02ed5">manager_kernel_type</a>, T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct iterator proxy. </p>

</div>
</div>
<a id="a2bb6a68e50275402ecf183c8ad00bc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6a68e50275402ecf183c8ad00bc29">&#9670;&nbsp;</a></span>instance_kind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">instance_kind</a> =  typename manager_kernel_type::instance_kind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An value that describes the type of the instance constructed in memory. </p>

</div>
</div>
<a id="a748fe63e04d58cedb365d17f84c2e1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748fe63e04d58cedb365d17f84c2e1ae">&#9670;&nbsp;</a></span>const_named_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a> =  typename manager_kernel_type::const_named_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for named objects. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a0">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6ac7b6423046445a8aa58b3d8d267720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac7b6423046445a8aa58b3d8d267720">&#9670;&nbsp;</a></span>const_unique_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a> =  typename manager_kernel_type::const_unique_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for unique objects. </p>

</div>
</div>
<a id="aafe466a3ab9fc8a6ad32ebe29deeafee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe466a3ab9fc8a6ad32ebe29deeafee">&#9670;&nbsp;</a></span>const_anonymous_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a> =  typename manager_kernel_type::const_anonymous_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for anonymous objects. </p>

</div>
</div>
<a id="a82455b70cbf57c44cbe0a0e1957dd3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82455b70cbf57c44cbe0a0e1957dd3e1">&#9670;&nbsp;</a></span>named_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a82455b70cbf57c44cbe0a0e1957dd3e1">named_object_attribute_accessor_type</a> =  typename manager_kernel_type::named_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to named object attribute. </p>

</div>
</div>
<a id="af4cd2592146b8a4737e22e4fd21fa1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd2592146b8a4737e22e4fd21fa1e2">&#9670;&nbsp;</a></span>unique_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#af4cd2592146b8a4737e22e4fd21fa1e2">unique_object_attribute_accessor_type</a> =  typename manager_kernel_type::unique_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to unique object attribute. </p>

</div>
</div>
<a id="a570ee47c700b22b2b0320e225f95e824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570ee47c700b22b2b0320e225f95e824">&#9670;&nbsp;</a></span>anonymous_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a570ee47c700b22b2b0320e225f95e824">anonymous_object_attribute_accessor_type</a> =  typename manager_kernel_type::anonymous_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to anonymous object attribute. </p>

</div>
</div>
<a id="a372b54cc19bad9c79e3b397f997bf8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372b54cc19bad9c79e3b397f997bf8f2">&#9670;&nbsp;</a></span>chunk_number_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a372b54cc19bad9c79e3b397f997bf8f2">chunk_number_type</a> =  chunk_no_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chunk number type (= chunk_no_type) </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afff9d2fe24574ba43db2e0df21fd5492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff9d2fe24574ba43db2e0df21fd5492">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1open__only__t.html">open_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing data store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0a2c3ddf07bdffe3d07d653a88af080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a2c3ddf07bdffe3d07d653a88af080">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1open__read__only__t.html">open_read_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing data store with the read only mode. Write accesses will cause segmentation fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d636fd6aae55366338cf7afd32f1d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d636fd6aae55366338cf7afd32f1d5e">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new data store (an existing data store will be overwritten). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to create a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c19e2c19d114cb0820c4777769f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c19e2c19d114cb0820c4777769f23af">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new data store (an existing data store will be overwritten). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to create a data store. </td></tr>
    <tr><td class="paramname">capacity</td><td>Maximum total allocation size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb6da3d6be384f15482f90673c67007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6da3d6be384f15482f90673c67007e">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>

</div>
</div>
<a id="a8aa9cfc8bb26f7624c4a5683cec2e6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa9cfc8bb26f7624c4a5683cec2e6f6">&#9670;&nbsp;</a></span>~basic_manager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::~<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="ac1ea252b2d3347f1a29156a536d45385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ea252b2d3347f1a29156a536d45385">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>

</div>
</div>
<a id="a3c259f26f9fe6ab9458f4cbe199177b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c259f26f9fe6ab9458f4cbe199177b5">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8dc065ea6fd0de68de273c6515de7ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc065ea6fd0de68de273c6515de7ee7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&amp; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>
<dl class="section return"><dt>Returns</dt><dd>N/A. </dd></dl>

</div>
</div>
<a id="a7aee4e322b3282f069c20e8e86bf8685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aee4e322b3282f069c20e8e86bf8685">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&amp; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>An reference to the object. </dd></dl>

</div>
</div>
<a id="a5969e8d2fb5cd08117b3997b01e43154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5969e8d2fb5cd08117b3997b01e43154">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object of type T. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)(arg1, arg2...);</div>
<div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](arg1, arg2...);</div>
</div><!-- fragment --><p> Where, 'arg1, arg2...' are the arguments passed to T's constructor via a proxy object. One can also construct an array using '[ ]' operator. When an array is constructed, each object receives the same arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that constructs the object on the allocated space. Returns nullptr if the name was used or it failed to allocate memory. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="metall_containers_8cpp-example.html#a3">metall_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ef134b01c3d3870e18900b0d5d45125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef134b01c3d3870e18900b0d5d45125">&#9670;&nbsp;</a></span>find_or_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ac2a112e98756c6950dc0d88d18b70c14">construct_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::find_or_construct </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an already constructed object. If not exist, constructs an object of type T. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.find_or_construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)(arg1, arg2...);</div>
<div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.find_or_construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](arg1, arg2...);</div>
</div><!-- fragment --><p> Where, 'arg1, arg2...' are the arguments passed to T's constructor via a proxy object. One can also construct an array using '[ ]' operator. When an array is constructed, each object receives the same arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that holds a pointer of an already constructed object or an object newly constructed. </dd></dl>

</div>
</div>
<a id="abf2d815b2bebb6fbb2995fedd586074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2d815b2bebb6fbb2995fedd586074f">&#9670;&nbsp;</a></span>construct_it()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::construct_it </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array of objects of type T, receiving arguments from iterators. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.construct_it&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](it1, it2...);</div>
</div><!-- fragment --><p> Each object receives parameters returned with the expression (*it1++, *it2++,... ).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object to construct an array of objects. </dd></dl>

</div>
</div>
<a id="aeed20085551d94d4afb0b90a261c6999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed20085551d94d4afb0b90a261c6999">&#9670;&nbsp;</a></span>find_or_construct_it()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#abf749c86b4771dcf828d44d8ab41d000">construct_iter_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::find_or_construct_it </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an already constructed object. If not exist, constructs an array of objects of type T, receiving arguments from iterators. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.find_or_construct_it&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](it1, it2...);</div>
</div><!-- fragment --><p> Each object receives parameters returned with the expression (*it1++, *it2++,... ).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that holds a pointer to the already constructed object or constructs an array of objects or just holds an pointer. </dd></dl>

</div>
</div>
<a id="a9754b815d4f0186d01c45d736dbf4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754b815d4f0186d01c45d736dbf4f6b">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T *, <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::find </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find a previously created object. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). </p><dl class="section warning"><dt>Warning</dt><dd>There is no mutex inside. Calling this function with other construct/destroy methods that updates an object directory simultaneously will cause a concurrent issue.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::pair&lt;T *, std::size_t&gt; ret = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.find&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the object and the count (if it is not an array, returns 1). If not present, nullptr is returned. </dd></dl>

</div>
</div>
<a id="a6198d2ec97fbd605f249123cebdef09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6198d2ec97fbd605f249123cebdef09f">&#9670;&nbsp;</a></span>destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a previously created object. Calls the destructor and frees the memory. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.destroy&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. </dd></dl>

</div>
</div>
<a id="aa7b07fec3f2a459967ebfa7499f57d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b07fec3f2a459967ebfa7499f57d91">&#9670;&nbsp;</a></span>destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">const metall::mtlldetail::unique_instance_t * const&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a unique object of type T. Calls the destructor and frees the memory. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.destroy&lt;T&gt;(metall::unique_instance);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. </dd></dl>

</div>
</div>
<a id="a5414147f5df62113d7a544647eb88135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5414147f5df62113d7a544647eb88135">&#9670;&nbsp;</a></span>destroy_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::destroy_ptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a object (named, unique, or anonymous) by its address. Calls the destructor and frees the memory. Cannot destroy an object not allocated by construct/find_or_construct functions. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.destroy_ptr&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. Note that the original API developed by Boost.Interprocess library does not return value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="metall_containers_8cpp-example.html#a5">metall_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a204164d125dc38d1468476ecf208c4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204164d125dc38d1468476ecf208c4da">&#9670;&nbsp;</a></span>get_instance_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a>* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_instance_name </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of an object created with construct/find_or_construct functions. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> name = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.get_instance_name&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the object. If ptr points to an unique instance, typeid(T).name() is returned. If ptr points to an anonymous instance or memory not allocated by construct/find_or_construct functions, nullptr is returned. </dd></dl>

</div>
</div>
<a id="ac81c86f7aaa1c1a174fd579a495830e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81c86f7aaa1c1a174fd579a495830e7">&#9670;&nbsp;</a></span>get_instance_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">instance_kind</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_instance_kind </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kind of an object created with construct/find_or_construct functions. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">instance_kind</a> t = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.get_instance_kind&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the object. </dd></dl>

</div>
</div>
<a id="ae2f9ee419d5ed745d889b676758d5e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f9ee419d5ed745d889b676758d5e1b">&#9670;&nbsp;</a></span>get_instance_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_instance_length </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of an object created with construct/find_or_construct functions (1 if is a single element, &gt;=1 if it's an array). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> length = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.get_instance_length&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the object. </dd></dl>

</div>
</div>
<a id="aae227081782b1357e180f1b5e5e70a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae227081782b1357e180f1b5e5e70a5e">&#9670;&nbsp;</a></span>is_instance_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::is_instance_type </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the type of an object, which was created with construct/find_or_construct functions, is T. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> correct_type = <a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.type&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A expected type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if T is correct; otherwise false. </dd></dl>

</div>
</div>
<a id="a79657e540e426fe8494595fc29125a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79657e540e426fe8494595fc29125a14">&#9670;&nbsp;</a></span>get_instance_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_instance_description </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the description of an object created with construct/find_or_construct. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">std::string</a> description;</div>
<div class="line"><a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.get_instance_description&lt;T&gt;(ptr, &amp;description);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramname">description</td><td>A pointer to a string buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false on error. </dd></dl>

</div>
</div>
<a id="a1fa7a3ceca561100d782dd867260c31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa7a3ceca561100d782dd867260c31a">&#9670;&nbsp;</a></span>set_instance_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::set_instance_description </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to an object created with construct/find_or_construct. </p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">std::string</a> description;</div>
<div class="line"><a class="code" href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">basic_manager</a>.set_instance_description&lt;T&gt;(ptr, description);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramname">description</td><td>A description to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false on error. </dd></dl>

</div>
</div>
<a id="a0b2ec162eae5499c41b897ba4debf61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2ec162eae5499c41b897ba4debf61d">&#9670;&nbsp;</a></span>get_num_named_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_num_named_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of named objects stored in the managed segment. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>The number of named objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="aaa814b3cf538ccb15b5a4ca3a820c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa814b3cf538ccb15b5a4ca3a820c775">&#9670;&nbsp;</a></span>get_num_unique_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_num_unique_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of unique objects stored in the managed segment. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>The number of unique objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="a55910f75d630b6d82382a5f542b07e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55910f75d630b6d82382a5f542b07e8f">&#9670;&nbsp;</a></span>get_num_anonymous_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_num_anonymous_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of anonymous objects (objects constructed with metall::anonymous_instance) stored in the managed segment. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of anonymous objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="ae13e2244acc4b5665c49629889d87936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e2244acc4b5665c49629889d87936">&#9670;&nbsp;</a></span>named_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::named_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the named objects. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the named objects. </dd></dl>

</div>
</div>
<a id="ae23d6c0aafb56d7a89a031b86a7355e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23d6c0aafb56d7a89a031b86a7355e8">&#9670;&nbsp;</a></span>named_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a748fe63e04d58cedb365d17f84c2e1ae">const_named_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::named_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the named allocations. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="ad246a8d9ecd8f6f468a186fb97f6f5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad246a8d9ecd8f6f468a186fb97f6f5b3">&#9670;&nbsp;</a></span>unique_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::unique_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the unique objects. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the unique objects. </dd></dl>

</div>
</div>
<a id="a85f5e9425c520764d43c9afaea4cf732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f5e9425c520764d43c9afaea4cf732">&#9670;&nbsp;</a></span>unique_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a6ac7b6423046445a8aa58b3d8d267720">const_unique_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::unique_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the unique allocations. NOT thread-safe. Never throws. </p>
<p>Object construction API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a> A named object must be associated with non-empty name. The name of an unique object is typeid(T).name().</p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="a56d110ce0188fbe9e1ff573419b8710e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d110ce0188fbe9e1ff573419b8710e">&#9670;&nbsp;</a></span>anonymous_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::anonymous_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the anonymous objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the anonymous objects. </dd></dl>

</div>
</div>
<a id="a41a3b3de6dfd6ed06fd6a1e9a5e0c021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a3b3de6dfd6ed06fd6a1e9a5e0c021">&#9670;&nbsp;</a></span>anonymous_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#aafe466a3ab9fc8a6ad32ebe29deeafee">const_anonymous_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::anonymous_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the anonymous allocations. NOT thread-safe. Never throws. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="a86580eab94bcf8aa5a7aeeff13bc97df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86580eab94bcf8aa5a7aeeff13bc97df">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates nbytes bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="ae44fd6015d396865866ee627448acab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44fd6015d396865866ee627448acab0">&#9670;&nbsp;</a></span>allocate_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::allocate_aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a>&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates nbytes bytes. The address of the allocated memory will be a multiple of alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbytes</td><td>Number of bytes to allocate. Must be a multiple alignment. </td></tr>
    <tr><td class="paramname">alignment</td><td>Alignment size. Alignment must be a power of two and satisfy [min allocation size, chunk size]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="a4e71f9e005a4c87d0de9bc55df9db3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e71f9e005a4c87d0de9bc55df9db3b0">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates the allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to the allocated memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57d2ee578e6de1fdbc5f541657cfb6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d2ee578e6de1fdbc5f541657cfb6b0">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>synchronous</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush data to persistent memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synchronous</td><td>If true, performs synchronous operation; otherwise, performs asynchronous operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9116d586f8c86b04c355953f5efc3264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116d586f8c86b04c355953f5efc3264">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>destination_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a snapshot of the current data. The snapshot has a new UUID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_dir_path</td><td>Path to store a snapshot. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available. </td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; other false. </dd></dl>

</div>
</div>
<a id="ab721ac4255db8300c2dbcfc0686ec108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab721ac4255db8300c2dbcfc0686ec108">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>source_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>destination_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data store synchronously. The behavior of copying a data store that is open without the read-only mode is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_dir_path</td><td>Source data store path. </td></tr>
    <tr><td class="paramname">destination_dir_path</td><td>Destination data store path. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available. </td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If succeeded, returns true; other false. </dd></dl>

</div>
</div>
<a id="aba83098558d6f2dbe4892071b345bf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba83098558d6f2dbe4892071b345bf10">&#9670;&nbsp;</a></span>copy_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>source_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>destination_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data store asynchronously. The behavior of copying a data store that is open without the read-only mode is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_dir_path</td><td>Source data store path. </td></tr>
    <tr><td class="paramname">destination_dir_path</td><td>Destination data store path. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available. </td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an object of std::future. If succeeded, its get() returns true; other false. </dd></dl>

</div>
</div>
<a id="a3ad76e66a54b5d32a323949321603173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad76e66a54b5d32a323949321603173">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes data store synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If succeeded, returns true; other false. </dd></dl>

</div>
</div>
<a id="a8515e65f2375a5b75f6b96e774c45f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8515e65f2375a5b75f6b96e774c45f45">&#9670;&nbsp;</a></span>remove_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::future&lt;bool&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::remove_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove data store asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an object of std::future. If succeeded, its get() returns true; other false </dd></dl>

</div>
</div>
<a id="acf7c87f6f553405e86eb4221e1972b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7c87f6f553405e86eb4221e1972b44">&#9670;&nbsp;</a></span>consistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::consistent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a data store exists and is consistent (i.e., it was closed properly in the previous run). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if it exists and is consistent; otherwise, returns false. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="snapshot_8cpp-example.html#a4">snapshot.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5c017dfee8914fcd0916d70b7b765357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c017dfee8914fcd0916d70b7b765357">&#9670;&nbsp;</a></span>get_uuid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_uuid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a UUID of the data store. </p>
<dl class="section return"><dt>Returns</dt><dd>UUID in the std::string format; returns an empty string on error. </dd></dl>

</div>
</div>
<a id="a1c454555ec0e5cfbdbbfb59c84b842c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c454555ec0e5cfbdbbfb59c84b842c2">&#9670;&nbsp;</a></span>get_uuid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_uuid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a UUID of the data store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UUID in the std::string format; returns an empty string on error. </dd></dl>

</div>
</div>
<a id="a77e05b27dc7c5b0d11a6e08b9bd23311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e05b27dc7c5b0d11a6e08b9bd23311">&#9670;&nbsp;</a></span>get_version() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the version of the Metall that created the backing data store. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a version number; returns 0 on error. </dd></dl>

</div>
</div>
<a id="a4610e0a74c12b9c5dfc4afe843dcf67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4610e0a74c12b9c5dfc4afe843dcf67c">&#9670;&nbsp;</a></span>get_version() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_version </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">char_type</a> *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the version of the Metall that created the backing data store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a version number; returns 0 on error. </dd></dl>

</div>
</div>
<a id="a412da2f484c6d5246541ee5b874de9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412da2f484c6d5246541ee5b874de9d1">&#9670;&nbsp;</a></span>set_description() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::set_description </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to a Metall data store. An existing description is overwritten (only one description per data store). </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is not thread-safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>An std::string object that holds a description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; otherwise, false. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="datastore_description_8cpp-example.html#a4">datastore_description.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab938a60344e09a64d36b5c85cedef572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab938a60344e09a64d36b5c85cedef572">&#9670;&nbsp;</a></span>set_description() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::set_description </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to a Metall data store. An existing description is overwritten (only one description per data store). </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe. Updating the same data store with multiple threads simultaneously could cause an issue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
    <tr><td class="paramname">description</td><td>An std::string object that holds a description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; otherwise, false. </dd></dl>

</div>
</div>
<a id="a2e2d7866d60dd88791fd78119fa09562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2d7866d60dd88791fd78119fa09562">&#9670;&nbsp;</a></span>get_description() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_description </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a description. If there is no description, nothing to happen to the given description object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>A pointer to an std::string object to store a description if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; returns false on error. Trying to get a non-existent description is not considered as an error. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="datastore_description_8cpp-example.html#a5">datastore_description.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7a2e1fc534e424ae1e76e16e1a176e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2e1fc534e424ae1e76e16e1a176e9d">&#9670;&nbsp;</a></span>get_description() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_description </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a description. If there is no description, nothing to happen to the given description object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
    <tr><td class="paramname">description</td><td>A pointer to an std::string object to store a description if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; returns false on error. Trying to get a non-existent description is not considered as an error. </dd></dl>

</div>
</div>
<a id="a5fb6c05e33ba6f3c946d22f2d3156778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb6c05e33ba6f3c946d22f2d3156778">&#9670;&nbsp;</a></span>access_named_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#a82455b70cbf57c44cbe0a0e1957dd3e1">named_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::access_named_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of named objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of named_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_8cpp-example.html#a4">object_attribute.cpp</a>, and <a class="el" href="object_attribute_api_list_8cpp-example.html#a5">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a641acc514ae2f485511ba4b7be4cc320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641acc514ae2f485511ba4b7be4cc320">&#9670;&nbsp;</a></span>access_unique_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#af4cd2592146b8a4737e22e4fd21fa1e2">unique_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::access_unique_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of unique object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of unique_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a6">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3e84077c8ae012c4c4dd644c000e36a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84077c8ae012c4c4dd644c000e36a8">&#9670;&nbsp;</a></span>access_anonymous_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#a570ee47c700b22b2b0320e225f95e824">anonymous_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::access_anonymous_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of anonymous object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of anonymous_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a7">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7017ce2a65fbfd7840d83d5e596e4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7017ce2a65fbfd7840d83d5e596e4b9">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T  = std::byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a1b0ef8e2a0ebcb1555316b2b2dbd8dbb">allocator_type</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a STL compatible allocator object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a STL compatible allocator object. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="metall_containers_8cpp-example.html#a4">metall_containers.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a669faef5d9504e7c7f8aa0337b29f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669faef5d9504e7c7f8aa0337b29f506">&#9670;&nbsp;</a></span>chunk_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::chunk_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal chunk size. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of internal chunk size. </dd></dl>

</div>
</div>
<a id="af0630bdfbda0fa676f288c2c63a1c3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0630bdfbda0fa676f288c2c63a1c3be">&#9670;&nbsp;</a></span>get_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the address of the application data segment. </p>
<dl class="section return"><dt>Returns</dt><dd>The address of the application data segment. </dd></dl>

</div>
</div>
<a id="a5fa2f79e199ec2be2f6da179802a6485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa2f79e199ec2be2f6da179802a6485">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size (i.e., the maximum total allocation size) of the application data segment. This is a theoretical value. The actual total allocation size Metall can handle will be less than that. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the application data segment. </dd></dl>

</div>
</div>
<a id="a38ad0f6a040457a73e9d9f0dc41ce797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ad0f6a040457a73e9d9f0dc41ce797">&#9670;&nbsp;</a></span>check_sanity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; chunk_no_type, k_chunk_size &gt;::check_sanity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/metall/metall/include/metall/<a class="el" href="basic__manager_8hpp_source.html">basic_manager.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a81bcb1cb53a0c5a33b02ef3f32ca513d"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a81bcb1cb53a0c5a33b02ef3f32ca513d">metall::basic_manager::size_type</a></div><div class="ttdeci">typename manager_kernel_type::size_type size_type</div><div class="ttdoc">Size type.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:46</div></div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a2bb6a68e50275402ecf183c8ad00bc29"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a2bb6a68e50275402ecf183c8ad00bc29">metall::basic_manager::instance_kind</a></div><div class="ttdeci">typename manager_kernel_type::instance_kind instance_kind</div><div class="ttdoc">An value that describes the type of the instance constructed in memory.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:68</div></div>
<div class="ttc" id="anamespacemetall_1_1container_html_a5fe499903b179ed596cd8c2bd6892009"><div class="ttname"><a href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">metall::container::string</a></div><div class="ttdeci">basic_string&lt; char &gt; string</div><div class="ttdoc">A string container that uses char as its character type and Metall as its default allocator.</div><div class="ttdef"><b>Definition:</b> string.hpp:23</div></div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_aeb6da3d6be384f15482f90673c67007e"><div class="ttname"><a href="classmetall_1_1basic__manager.html#aeb6da3d6be384f15482f90673c67007e">metall::basic_manager::basic_manager</a></div><div class="ttdeci">basic_manager()=delete</div><div class="ttdoc">Deleted.</div></div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a6a734b956eabae70adae4a1432f599cf"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a6a734b956eabae70adae4a1432f599cf">metall::basic_manager::char_type</a></div><div class="ttdeci">typename manager_kernel_type::char_type char_type</div><div class="ttdoc">Char type.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:43</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemetall.html">metall</a></li><li class="navelem"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
