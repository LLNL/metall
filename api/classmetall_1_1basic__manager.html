<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Metall: metall::basic_manager&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Metall
   &#160;<span id="projectnumber">v0.28</span>
   </div>
   <div id="projectbrief">A persistent memory allocator for data-centric analytics</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmetall_1_1basic__manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmetall_1_1basic__manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">metall::basic_manager&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generalized Metall manager class.  
 <a href="classmetall_1_1basic__manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="basic__manager_8hpp_source.html">/home/runner/work/metall/metall/include/metall/basic_manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a54d169d8e19b55f60edadd4e49b75193"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a> = kernel::manager_kernel&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;</td></tr>
<tr class="memdesc:a54d169d8e19b55f60edadd4e49b75193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager kernel type.  <a href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">More...</a><br /></td></tr>
<tr class="separator:a54d169d8e19b55f60edadd4e49b75193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afedb822522743317a6f0a784a4c91e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1afedb822522743317a6f0a784a4c91e">void_pointer</a> = typename manager_kernel_type::void_pointer</td></tr>
<tr class="memdesc:a1afedb822522743317a6f0a784a4c91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void pointer type.  <a href="classmetall_1_1basic__manager.html#a1afedb822522743317a6f0a784a4c91e">More...</a><br /></td></tr>
<tr class="separator:a1afedb822522743317a6f0a784a4c91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfdb46ac3ee9102dcd768e593b9a696"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">char_type</a> = typename manager_kernel_type::char_type</td></tr>
<tr class="memdesc:a3cfdb46ac3ee9102dcd768e593b9a696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char type.  <a href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">More...</a><br /></td></tr>
<tr class="separator:a3cfdb46ac3ee9102dcd768e593b9a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bed532efbe211f064b741fd8efdaacf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> = typename manager_kernel_type::size_type</td></tr>
<tr class="memdesc:a9bed532efbe211f064b741fd8efdaacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type.  <a href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">More...</a><br /></td></tr>
<tr class="separator:a9bed532efbe211f064b741fd8efdaacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b847c70cc6170acccbbae479d517a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a97b847c70cc6170acccbbae479d517a5">difference_type</a> = typename manager_kernel_type::difference_type</td></tr>
<tr class="memdesc:a97b847c70cc6170acccbbae479d517a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type.  <a href="classmetall_1_1basic__manager.html#a97b847c70cc6170acccbbae479d517a5">More...</a><br /></td></tr>
<tr class="separator:a97b847c70cc6170acccbbae479d517a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed111708cfcb17cfc53ad968fb845d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed111708cfcb17cfc53ad968fb845d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a> = <a class="el" href="classmetall_1_1stl__allocator.html">stl_allocator</a>&lt; T, <a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a> &gt;</td></tr>
<tr class="memdesc:a3ed111708cfcb17cfc53ad968fb845d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <a href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">More...</a><br /></td></tr>
<tr class="separator:a3ed111708cfcb17cfc53ad968fb845d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1ffa85cdf0b52371a3f401c75e6229"><td class="memTemplParams" colspan="2">template&lt;typename OuterT , typename... InnerT&gt; </td></tr>
<tr class="memitem:a9d1ffa85cdf0b52371a3f401c75e6229"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9d1ffa85cdf0b52371a3f401c75e6229">scoped_allocator_type</a> = <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt; <a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt; OuterT &gt;, <a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt; InnerT &gt;... &gt;</td></tr>
<tr class="memdesc:a9d1ffa85cdf0b52371a3f401c75e6229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type wrapped by scoped_allocator_adaptor.  <a href="classmetall_1_1basic__manager.html#a9d1ffa85cdf0b52371a3f401c75e6229">More...</a><br /></td></tr>
<tr class="separator:a9d1ffa85cdf0b52371a3f401c75e6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d7d0afc64fc115eb7db3820861c8b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1d7d0afc64fc115eb7db3820861c8b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac1d7d0afc64fc115eb7db3820861c8b1">fallback_allocator</a> = <a class="el" href="classmetall_1_1container_1_1fallback__allocator__adaptor.html">container::fallback_allocator_adaptor</a>&lt; <a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac1d7d0afc64fc115eb7db3820861c8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A STL compatible allocator which fallbacks to a heap allocator (e.g., malloc()) if no argument is provided to construct a allocator_type instance.  <a href="classmetall_1_1basic__manager.html#ac1d7d0afc64fc115eb7db3820861c8b1">More...</a><br /></td></tr>
<tr class="separator:ac1d7d0afc64fc115eb7db3820861c8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae890b76027335cee42c2c3f9c5f1c621"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae890b76027335cee42c2c3f9c5f1c621"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ae890b76027335cee42c2c3f9c5f1c621">scoped_fallback_allocator_type</a> = <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt; <a class="el" href="classmetall_1_1basic__manager.html#ac1d7d0afc64fc115eb7db3820861c8b1">fallback_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ae890b76027335cee42c2c3f9c5f1c621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback allocator type wrapped by scoped_allocator_adaptor.  <a href="classmetall_1_1basic__manager.html#ae890b76027335cee42c2c3f9c5f1c621">More...</a><br /></td></tr>
<tr class="separator:ae890b76027335cee42c2c3f9c5f1c621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c54d498f9608d0b27bcaab2240e60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a312c54d498f9608d0b27bcaab2240e60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a> = metall::mtlldetail::named_proxy&lt; <a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a>, T, false &gt;</td></tr>
<tr class="memdesc:a312c54d498f9608d0b27bcaab2240e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct proxy.  <a href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">More...</a><br /></td></tr>
<tr class="separator:a312c54d498f9608d0b27bcaab2240e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7707e4a1376bd27db5df59cfbb09c52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7707e4a1376bd27db5df59cfbb09c52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a> = metall::mtlldetail::named_proxy&lt; <a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a>, T, true &gt;</td></tr>
<tr class="memdesc:ad7707e4a1376bd27db5df59cfbb09c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct iterator proxy.  <a href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">More...</a><br /></td></tr>
<tr class="separator:ad7707e4a1376bd27db5df59cfbb09c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4787bd6efa19807d37ab4ae101e3ca7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">instance_kind</a> = typename manager_kernel_type::instance_kind</td></tr>
<tr class="memdesc:a4787bd6efa19807d37ab4ae101e3ca7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An value that describes the type of the instance constructed in memory.  <a href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">More...</a><br /></td></tr>
<tr class="separator:a4787bd6efa19807d37ab4ae101e3ca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca584b4be45b2bd5f28e458e73d9439"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a> = typename manager_kernel_type::const_named_iterator</td></tr>
<tr class="memdesc:a7ca584b4be45b2bd5f28e458e73d9439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for named objects.  <a href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">More...</a><br /></td></tr>
<tr class="separator:a7ca584b4be45b2bd5f28e458e73d9439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762dc63d6853c1eedc7dd73e1e286423"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a> = typename manager_kernel_type::const_unique_iterator</td></tr>
<tr class="memdesc:a762dc63d6853c1eedc7dd73e1e286423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for unique objects.  <a href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">More...</a><br /></td></tr>
<tr class="separator:a762dc63d6853c1eedc7dd73e1e286423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f060036d966e34fe0725058787ba6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a> = typename manager_kernel_type::const_anonymous_iterator</td></tr>
<tr class="memdesc:ab27f060036d966e34fe0725058787ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator for anonymous objects.  <a href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">More...</a><br /></td></tr>
<tr class="separator:ab27f060036d966e34fe0725058787ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8599f64b9f87fa30a0c45644d50d728"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af8599f64b9f87fa30a0c45644d50d728">named_object_attribute_accessor_type</a> = typename manager_kernel_type::named_object_attr_accessor_type</td></tr>
<tr class="memdesc:af8599f64b9f87fa30a0c45644d50d728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to named object attribute.  <a href="classmetall_1_1basic__manager.html#af8599f64b9f87fa30a0c45644d50d728">More...</a><br /></td></tr>
<tr class="separator:af8599f64b9f87fa30a0c45644d50d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1151eb95d988f6eb46a2cdeb7016048a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1151eb95d988f6eb46a2cdeb7016048a">unique_object_attribute_accessor_type</a> = typename manager_kernel_type::unique_object_attr_accessor_type</td></tr>
<tr class="memdesc:a1151eb95d988f6eb46a2cdeb7016048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to unique object attribute.  <a href="classmetall_1_1basic__manager.html#a1151eb95d988f6eb46a2cdeb7016048a">More...</a><br /></td></tr>
<tr class="separator:a1151eb95d988f6eb46a2cdeb7016048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4983c6a23ab89f2fd13127f78db3da51"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4983c6a23ab89f2fd13127f78db3da51">anonymous_object_attribute_accessor_type</a> = typename manager_kernel_type::anonymous_object_attr_accessor_type</td></tr>
<tr class="memdesc:a4983c6a23ab89f2fd13127f78db3da51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to anonymous object attribute.  <a href="classmetall_1_1basic__manager.html#a4983c6a23ab89f2fd13127f78db3da51">More...</a><br /></td></tr>
<tr class="separator:a4983c6a23ab89f2fd13127f78db3da51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d325cc1b5a88b580f9454533ea2fe6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4d325cc1b5a88b580f9454533ea2fe6e">chunk_number_type</a> = chunk_no_type</td></tr>
<tr class="memdesc:a4d325cc1b5a88b580f9454533ea2fe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunk number type (= chunk_no_type)  <a href="classmetall_1_1basic__manager.html#a4d325cc1b5a88b580f9454533ea2fe6e">More...</a><br /></td></tr>
<tr class="separator:a4d325cc1b5a88b580f9454533ea2fe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2301ccf45568d8ecc03ba2c8a1019b04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> = typename manager_kernel_type::path_type</td></tr>
<tr class="memdesc:a2301ccf45568d8ecc03ba2c8a1019b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path type.  <a href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">More...</a><br /></td></tr>
<tr class="separator:a2301ccf45568d8ecc03ba2c8a1019b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4748a26a6ab4da4a807e043d515f3f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4748a26a6ab4da4a807e043d515f3f29">basic_manager</a> (<a class="el" href="structmetall_1_1open__only__t.html">open_only_t</a>, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;base_path) noexcept</td></tr>
<tr class="memdesc:a4748a26a6ab4da4a807e043d515f3f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing data store.  <a href="classmetall_1_1basic__manager.html#a4748a26a6ab4da4a807e043d515f3f29">More...</a><br /></td></tr>
<tr class="separator:a4748a26a6ab4da4a807e043d515f3f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6c92e9e758f990c2f81b92c5e0fb82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2a6c92e9e758f990c2f81b92c5e0fb82">basic_manager</a> (<a class="el" href="structmetall_1_1open__read__only__t.html">open_read_only_t</a>, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;base_path) noexcept</td></tr>
<tr class="memdesc:a2a6c92e9e758f990c2f81b92c5e0fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing data store with the read only mode. Write accesses will cause segmentation fault.  <a href="classmetall_1_1basic__manager.html#a2a6c92e9e758f990c2f81b92c5e0fb82">More...</a><br /></td></tr>
<tr class="separator:a2a6c92e9e758f990c2f81b92c5e0fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5a3c5820987e2941b43a425b175c43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4b5a3c5820987e2941b43a425b175c43">basic_manager</a> (<a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;base_path) noexcept</td></tr>
<tr class="memdesc:a4b5a3c5820987e2941b43a425b175c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new data store (an existing data store will be overwritten).  <a href="classmetall_1_1basic__manager.html#a4b5a3c5820987e2941b43a425b175c43">More...</a><br /></td></tr>
<tr class="separator:a4b5a3c5820987e2941b43a425b175c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe475f071a697c5d6f19ec47250392f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a0fe475f071a697c5d6f19ec47250392f">basic_manager</a> (<a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;base_path, const <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> capacity) noexcept</td></tr>
<tr class="memdesc:a0fe475f071a697c5d6f19ec47250392f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new data store (an existing data store will be overwritten).  <a href="classmetall_1_1basic__manager.html#a0fe475f071a697c5d6f19ec47250392f">More...</a><br /></td></tr>
<tr class="separator:a0fe475f071a697c5d6f19ec47250392f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c91bf1086d26bfa83356fb9e3377df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a> ()=delete</td></tr>
<tr class="memdesc:a3c91bf1086d26bfa83356fb9e3377df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">More...</a><br /></td></tr>
<tr class="separator:a3c91bf1086d26bfa83356fb9e3377df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6057f4d19b8480e5da499f5b92aca009"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6057f4d19b8480e5da499f5b92aca009">~basic_manager</a> () noexcept=default</td></tr>
<tr class="memdesc:a6057f4d19b8480e5da499f5b92aca009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classmetall_1_1basic__manager.html#a6057f4d19b8480e5da499f5b92aca009">More...</a><br /></td></tr>
<tr class="separator:a6057f4d19b8480e5da499f5b92aca009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83d5cdb40dbbcc7dc3920a2a3231f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aba83d5cdb40dbbcc7dc3920a2a3231f0">basic_manager</a> (const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;)=delete</td></tr>
<tr class="memdesc:aba83d5cdb40dbbcc7dc3920a2a3231f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#aba83d5cdb40dbbcc7dc3920a2a3231f0">More...</a><br /></td></tr>
<tr class="separator:aba83d5cdb40dbbcc7dc3920a2a3231f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4113d7bba77d09b862d736e114c926ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4113d7bba77d09b862d736e114c926ea">basic_manager</a> (<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a4113d7bba77d09b862d736e114c926ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classmetall_1_1basic__manager.html#a4113d7bba77d09b862d736e114c926ea">More...</a><br /></td></tr>
<tr class="separator:a4113d7bba77d09b862d736e114c926ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6ecf9b74ad0009d39b6a6b4e395070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9f6ecf9b74ad0009d39b6a6b4e395070">operator=</a> (const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;)=delete</td></tr>
<tr class="memdesc:a9f6ecf9b74ad0009d39b6a6b4e395070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="classmetall_1_1basic__manager.html#a9f6ecf9b74ad0009d39b6a6b4e395070">More...</a><br /></td></tr>
<tr class="separator:a9f6ecf9b74ad0009d39b6a6b4e395070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120b4660c0396c0795c3b5bd09c4651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a0120b4660c0396c0795c3b5bd09c4651">operator=</a> (<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a0120b4660c0396c0795c3b5bd09c4651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classmetall_1_1basic__manager.html#a0120b4660c0396c0795c3b5bd09c4651">More...</a><br /></td></tr>
<tr class="separator:a0120b4660c0396c0795c3b5bd09c4651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d1eb83452cdc20bfcb9f76bf45ddff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14d1eb83452cdc20bfcb9f76bf45ddff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a14d1eb83452cdc20bfcb9f76bf45ddff">construct</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a14d1eb83452cdc20bfcb9f76bf45ddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object of type T.  <a href="classmetall_1_1basic__manager.html#a14d1eb83452cdc20bfcb9f76bf45ddff">More...</a><br /></td></tr>
<tr class="separator:a14d1eb83452cdc20bfcb9f76bf45ddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce5874be956d31bcd2c3337359eca46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ce5874be956d31bcd2c3337359eca46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a7ce5874be956d31bcd2c3337359eca46">find_or_construct</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a7ce5874be956d31bcd2c3337359eca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an already constructed object. If not exist, constructs an object of type T.  <a href="classmetall_1_1basic__manager.html#a7ce5874be956d31bcd2c3337359eca46">More...</a><br /></td></tr>
<tr class="separator:a7ce5874be956d31bcd2c3337359eca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6eb59c6e9485cf2d7d75336f34742e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d6eb59c6e9485cf2d7d75336f34742e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a3d6eb59c6e9485cf2d7d75336f34742e">construct_it</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a3d6eb59c6e9485cf2d7d75336f34742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array of objects of type T, receiving arguments from iterators.  <a href="classmetall_1_1basic__manager.html#a3d6eb59c6e9485cf2d7d75336f34742e">More...</a><br /></td></tr>
<tr class="separator:a3d6eb59c6e9485cf2d7d75336f34742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686bde74904756e2ba7ffb7a3b638b5c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a686bde74904756e2ba7ffb7a3b638b5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a686bde74904756e2ba7ffb7a3b638b5c">find_or_construct_it</a> (char_ptr_holder_type name)</td></tr>
<tr class="memdesc:a686bde74904756e2ba7ffb7a3b638b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find an already constructed object. If not exist, constructs an array of objects of type T, receiving arguments from iterators.  <a href="classmetall_1_1basic__manager.html#a686bde74904756e2ba7ffb7a3b638b5c">More...</a><br /></td></tr>
<tr class="separator:a686bde74904756e2ba7ffb7a3b638b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc48c56877a7feb606d3f8c08b0e5dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfc48c56877a7feb606d3f8c08b0e5dd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T *, <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#acfc48c56877a7feb606d3f8c08b0e5dd">find</a> (char_ptr_holder_type name) const noexcept</td></tr>
<tr class="memdesc:acfc48c56877a7feb606d3f8c08b0e5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a previously created object.  <a href="classmetall_1_1basic__manager.html#acfc48c56877a7feb606d3f8c08b0e5dd">More...</a><br /></td></tr>
<tr class="separator:acfc48c56877a7feb606d3f8c08b0e5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cb9dd2ed9e5b2554cb59422da8a7fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0cb9dd2ed9e5b2554cb59422da8a7fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af0cb9dd2ed9e5b2554cb59422da8a7fa">destroy</a> (const char *name)</td></tr>
<tr class="memdesc:af0cb9dd2ed9e5b2554cb59422da8a7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a previously created object. Calls the destructor and frees the memory.  <a href="classmetall_1_1basic__manager.html#af0cb9dd2ed9e5b2554cb59422da8a7fa">More...</a><br /></td></tr>
<tr class="separator:af0cb9dd2ed9e5b2554cb59422da8a7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9800fbd65ec2a7cedf05503e6194798a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9800fbd65ec2a7cedf05503e6194798a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9800fbd65ec2a7cedf05503e6194798a">destroy</a> (const metall::mtlldetail::unique_instance_t *const)</td></tr>
<tr class="memdesc:a9800fbd65ec2a7cedf05503e6194798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a unique object of type T. Calls the destructor and frees the memory.  <a href="classmetall_1_1basic__manager.html#a9800fbd65ec2a7cedf05503e6194798a">More...</a><br /></td></tr>
<tr class="separator:a9800fbd65ec2a7cedf05503e6194798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b49c024ec2944a9d6b4c4fa570a064"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a35b49c024ec2944a9d6b4c4fa570a064"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a35b49c024ec2944a9d6b4c4fa570a064">destroy_ptr</a> (const T *ptr)</td></tr>
<tr class="memdesc:a35b49c024ec2944a9d6b4c4fa570a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a object (named, unique, or anonymous) by its address. Calls the destructor and frees the memory. Cannot destroy an object not allocated by construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#a35b49c024ec2944a9d6b4c4fa570a064">More...</a><br /></td></tr>
<tr class="separator:a35b49c024ec2944a9d6b4c4fa570a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472a57e70e9f8ba6fefd1ee11949da23"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a472a57e70e9f8ba6fefd1ee11949da23"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">char_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a472a57e70e9f8ba6fefd1ee11949da23">get_instance_name</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:a472a57e70e9f8ba6fefd1ee11949da23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an object created with construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#a472a57e70e9f8ba6fefd1ee11949da23">More...</a><br /></td></tr>
<tr class="separator:a472a57e70e9f8ba6fefd1ee11949da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6654ceed688e46fa6b07ca1984436d69"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6654ceed688e46fa6b07ca1984436d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">instance_kind</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a6654ceed688e46fa6b07ca1984436d69">get_instance_kind</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:a6654ceed688e46fa6b07ca1984436d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of an object created with construct/find_or_construct functions.  <a href="classmetall_1_1basic__manager.html#a6654ceed688e46fa6b07ca1984436d69">More...</a><br /></td></tr>
<tr class="separator:a6654ceed688e46fa6b07ca1984436d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff58b1a97818aa51d84219d74bb3ed5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ff58b1a97818aa51d84219d74bb3ed5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2ff58b1a97818aa51d84219d74bb3ed5">get_instance_length</a> (const T *ptr) const noexcept</td></tr>
<tr class="memdesc:a2ff58b1a97818aa51d84219d74bb3ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of an object created with construct/find_or_construct functions (1 if is a single element, &gt;=1 if it's an array).  <a href="classmetall_1_1basic__manager.html#a2ff58b1a97818aa51d84219d74bb3ed5">More...</a><br /></td></tr>
<tr class="separator:a2ff58b1a97818aa51d84219d74bb3ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47faa10a26dd2a7892ac7d3fc24807b1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a47faa10a26dd2a7892ac7d3fc24807b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a47faa10a26dd2a7892ac7d3fc24807b1">is_instance_type</a> (const void *const ptr) const noexcept</td></tr>
<tr class="memdesc:a47faa10a26dd2a7892ac7d3fc24807b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the type of an object, which was created with construct/find_or_construct functions, is T.  <a href="classmetall_1_1basic__manager.html#a47faa10a26dd2a7892ac7d3fc24807b1">More...</a><br /></td></tr>
<tr class="separator:a47faa10a26dd2a7892ac7d3fc24807b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f88d2fbcefa2b8dba5d7894326596a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a53f88d2fbcefa2b8dba5d7894326596a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a53f88d2fbcefa2b8dba5d7894326596a">get_instance_description</a> (const T *ptr, std::string *description) const noexcept</td></tr>
<tr class="memdesc:a53f88d2fbcefa2b8dba5d7894326596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the description of an object created with construct/find_or_construct.  <a href="classmetall_1_1basic__manager.html#a53f88d2fbcefa2b8dba5d7894326596a">More...</a><br /></td></tr>
<tr class="separator:a53f88d2fbcefa2b8dba5d7894326596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa662835a1039b16aeaf59cd1de1b459c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa662835a1039b16aeaf59cd1de1b459c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aa662835a1039b16aeaf59cd1de1b459c">set_instance_description</a> (const T *ptr, const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:aa662835a1039b16aeaf59cd1de1b459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to an object created with construct/find_or_construct.  <a href="classmetall_1_1basic__manager.html#aa662835a1039b16aeaf59cd1de1b459c">More...</a><br /></td></tr>
<tr class="separator:aa662835a1039b16aeaf59cd1de1b459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec8bd3463abdb8f132d931ad64abb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aaec8bd3463abdb8f132d931ad64abb5b">get_num_named_objects</a> () const noexcept</td></tr>
<tr class="memdesc:aaec8bd3463abdb8f132d931ad64abb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of named objects stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#aaec8bd3463abdb8f132d931ad64abb5b">More...</a><br /></td></tr>
<tr class="separator:aaec8bd3463abdb8f132d931ad64abb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38f03d7a9a8d0280d887fe06571fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#afe38f03d7a9a8d0280d887fe06571fd7">get_num_unique_objects</a> () const noexcept</td></tr>
<tr class="memdesc:afe38f03d7a9a8d0280d887fe06571fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of unique objects stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#afe38f03d7a9a8d0280d887fe06571fd7">More...</a><br /></td></tr>
<tr class="separator:afe38f03d7a9a8d0280d887fe06571fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fec18fc8010c90726994a470efad46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a70fec18fc8010c90726994a470efad46">get_num_anonymous_objects</a> () const noexcept</td></tr>
<tr class="memdesc:a70fec18fc8010c90726994a470efad46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Returns the number of anonymous objects (objects constructed with metall::anonymous_instance) stored in the managed segment.  <a href="classmetall_1_1basic__manager.html#a70fec18fc8010c90726994a470efad46">More...</a><br /></td></tr>
<tr class="separator:a70fec18fc8010c90726994a470efad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dfa9f54756414cde0701786c5d9ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ad5dfa9f54756414cde0701786c5d9ddd">named_begin</a> () const noexcept</td></tr>
<tr class="memdesc:ad5dfa9f54756414cde0701786c5d9ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the named objects.  <a href="classmetall_1_1basic__manager.html#ad5dfa9f54756414cde0701786c5d9ddd">More...</a><br /></td></tr>
<tr class="separator:ad5dfa9f54756414cde0701786c5d9ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5e64bc1f9dfd430cff5e0f6bf60be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aeb5e64bc1f9dfd430cff5e0f6bf60be1">named_end</a> () const noexcept</td></tr>
<tr class="memdesc:aeb5e64bc1f9dfd430cff5e0f6bf60be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the named allocations.  <a href="classmetall_1_1basic__manager.html#aeb5e64bc1f9dfd430cff5e0f6bf60be1">More...</a><br /></td></tr>
<tr class="separator:aeb5e64bc1f9dfd430cff5e0f6bf60be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88e390c2d3bf12317f0ee32c1c6297e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab88e390c2d3bf12317f0ee32c1c6297e">unique_begin</a> () const noexcept</td></tr>
<tr class="memdesc:ab88e390c2d3bf12317f0ee32c1c6297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the unique objects.  <a href="classmetall_1_1basic__manager.html#ab88e390c2d3bf12317f0ee32c1c6297e">More...</a><br /></td></tr>
<tr class="separator:ab88e390c2d3bf12317f0ee32c1c6297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9928024277f0c04200c2d4b94942a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a63f9928024277f0c04200c2d4b94942a">unique_end</a> () const noexcept</td></tr>
<tr class="memdesc:a63f9928024277f0c04200c2d4b94942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the unique allocations.  <a href="classmetall_1_1basic__manager.html#a63f9928024277f0c04200c2d4b94942a">More...</a><br /></td></tr>
<tr class="separator:a63f9928024277f0c04200c2d4b94942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9eeb82c79858b194b5428adcd2036f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a0b9eeb82c79858b194b5428adcd2036f">anonymous_begin</a> () const noexcept</td></tr>
<tr class="memdesc:a0b9eeb82c79858b194b5428adcd2036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the index storing the anonymous objects.  <a href="classmetall_1_1basic__manager.html#a0b9eeb82c79858b194b5428adcd2036f">More...</a><br /></td></tr>
<tr class="separator:a0b9eeb82c79858b194b5428adcd2036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac191291d2ecaad2f2ad7359286ff7ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ac191291d2ecaad2f2ad7359286ff7ea0">anonymous_end</a> () const noexcept</td></tr>
<tr class="memdesc:ac191291d2ecaad2f2ad7359286ff7ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the end of the index storing the anonymous allocations.  <a href="classmetall_1_1basic__manager.html#ac191291d2ecaad2f2ad7359286ff7ea0">More...</a><br /></td></tr>
<tr class="separator:ac191291d2ecaad2f2ad7359286ff7ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca202b915bf3c9ffeec887c1e49a7bb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a0ca202b915bf3c9ffeec887c1e49a7bb">allocate</a> (<a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> nbytes) noexcept</td></tr>
<tr class="memdesc:a0ca202b915bf3c9ffeec887c1e49a7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates nbytes bytes.  <a href="classmetall_1_1basic__manager.html#a0ca202b915bf3c9ffeec887c1e49a7bb">More...</a><br /></td></tr>
<tr class="separator:a0ca202b915bf3c9ffeec887c1e49a7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc00f1cd89d59407ecf7a98546bd9e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#af7bc00f1cd89d59407ecf7a98546bd9e">allocate_aligned</a> (<a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> nbytes, <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> alignment) noexcept</td></tr>
<tr class="memdesc:af7bc00f1cd89d59407ecf7a98546bd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates nbytes bytes. The address of the allocated memory will be a multiple of alignment.  <a href="classmetall_1_1basic__manager.html#af7bc00f1cd89d59407ecf7a98546bd9e">More...</a><br /></td></tr>
<tr class="separator:af7bc00f1cd89d59407ecf7a98546bd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8444b4a8a137fd2b76ebb9d74ad8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#acf8444b4a8a137fd2b76ebb9d74ad8a3">deallocate</a> (void *addr) noexcept</td></tr>
<tr class="memdesc:acf8444b4a8a137fd2b76ebb9d74ad8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the allocated memory.  <a href="classmetall_1_1basic__manager.html#acf8444b4a8a137fd2b76ebb9d74ad8a3">More...</a><br /></td></tr>
<tr class="separator:acf8444b4a8a137fd2b76ebb9d74ad8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc3fb6112aef4099be115cca0c0e7b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aadc3fb6112aef4099be115cca0c0e7b8">all_memory_deallocated</a> () const noexcept</td></tr>
<tr class="memdesc:aadc3fb6112aef4099be115cca0c0e7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all allocated memory has been deallocated.  <a href="classmetall_1_1basic__manager.html#aadc3fb6112aef4099be115cca0c0e7b8">More...</a><br /></td></tr>
<tr class="separator:aadc3fb6112aef4099be115cca0c0e7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65288af3fb9b7a74bec2c7b20ca6a237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a65288af3fb9b7a74bec2c7b20ca6a237">flush</a> (const bool synchronous=true) noexcept</td></tr>
<tr class="memdesc:a65288af3fb9b7a74bec2c7b20ca6a237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush data to persistent memory.  <a href="classmetall_1_1basic__manager.html#a65288af3fb9b7a74bec2c7b20ca6a237">More...</a><br /></td></tr>
<tr class="separator:a65288af3fb9b7a74bec2c7b20ca6a237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab483d61fda3f7acc91a22bfaddca0686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab483d61fda3f7acc91a22bfaddca0686">snapshot</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;destination_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:ab483d61fda3f7acc91a22bfaddca0686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a snapshot of the current data. The snapshot has a new UUID.  <a href="classmetall_1_1basic__manager.html#ab483d61fda3f7acc91a22bfaddca0686">More...</a><br /></td></tr>
<tr class="separator:ab483d61fda3f7acc91a22bfaddca0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07703de3f86b1d3a768e71a39adc91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#add07703de3f86b1d3a768e71a39adc91">get_uuid</a> () const noexcept</td></tr>
<tr class="memdesc:add07703de3f86b1d3a768e71a39adc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID of the data store.  <a href="classmetall_1_1basic__manager.html#add07703de3f86b1d3a768e71a39adc91">More...</a><br /></td></tr>
<tr class="separator:add07703de3f86b1d3a768e71a39adc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f60116d08306d45700953f325ec2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a86f60116d08306d45700953f325ec2fb">get_version</a> () const noexcept</td></tr>
<tr class="memdesc:a86f60116d08306d45700953f325ec2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version of the Metall that created the backing data store.  <a href="classmetall_1_1basic__manager.html#a86f60116d08306d45700953f325ec2fb">More...</a><br /></td></tr>
<tr class="separator:a86f60116d08306d45700953f325ec2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e2cae534c4ab97474875d0ad7e0a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a420e2cae534c4ab97474875d0ad7e0a6">set_description</a> (const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:a420e2cae534c4ab97474875d0ad7e0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to a Metall data store. An existing description is overwritten (only one description per data store).  <a href="classmetall_1_1basic__manager.html#a420e2cae534c4ab97474875d0ad7e0a6">More...</a><br /></td></tr>
<tr class="separator:a420e2cae534c4ab97474875d0ad7e0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663057f3a9841d76e0c0359e54f5e23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab663057f3a9841d76e0c0359e54f5e23">get_description</a> (std::string *description) const noexcept</td></tr>
<tr class="memdesc:ab663057f3a9841d76e0c0359e54f5e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a description. If there is no description, nothing to happen to the given description object.  <a href="classmetall_1_1basic__manager.html#ab663057f3a9841d76e0c0359e54f5e23">More...</a><br /></td></tr>
<tr class="separator:ab663057f3a9841d76e0c0359e54f5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546acd4b653b98c8ce93527526c10151"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::byte&gt; </td></tr>
<tr class="memitem:a546acd4b653b98c8ce93527526c10151"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a546acd4b653b98c8ce93527526c10151">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:a546acd4b653b98c8ce93527526c10151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a STL compatible allocator object.  <a href="classmetall_1_1basic__manager.html#a546acd4b653b98c8ce93527526c10151">More...</a><br /></td></tr>
<tr class="separator:a546acd4b653b98c8ce93527526c10151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca0c926ab3d3b0fa1d3de117704e1e2"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2ca0c926ab3d3b0fa1d3de117704e1e2">get_address</a> () const noexcept</td></tr>
<tr class="memdesc:a2ca0c926ab3d3b0fa1d3de117704e1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the application data segment.  <a href="classmetall_1_1basic__manager.html#a2ca0c926ab3d3b0fa1d3de117704e1e2">More...</a><br /></td></tr>
<tr class="separator:a2ca0c926ab3d3b0fa1d3de117704e1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c3a88625f83bbe60c08bd7c387a922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab6c3a88625f83bbe60c08bd7c387a922">get_size</a> () const noexcept</td></tr>
<tr class="memdesc:ab6c3a88625f83bbe60c08bd7c387a922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (i.e., the maximum total allocation size) of the application data segment. This is a theoretical value. The actual total allocation size Metall can handle will be less than that.  <a href="classmetall_1_1basic__manager.html#ab6c3a88625f83bbe60c08bd7c387a922">More...</a><br /></td></tr>
<tr class="separator:ab6c3a88625f83bbe60c08bd7c387a922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a7116bfa551d2b0335f26130c244de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a06a7116bfa551d2b0335f26130c244de">read_only</a> () const noexcept</td></tr>
<tr class="memdesc:a06a7116bfa551d2b0335f26130c244de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this manager was opened as read-only.  <a href="classmetall_1_1basic__manager.html#a06a7116bfa551d2b0335f26130c244de">More...</a><br /></td></tr>
<tr class="separator:a06a7116bfa551d2b0335f26130c244de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b408d0f8c031015235641c1117c17d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a77b408d0f8c031015235641c1117c17d">check_sanity</a> () const noexcept</td></tr>
<tr class="memdesc:a77b408d0f8c031015235641c1117c17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the sanity.  <a href="classmetall_1_1basic__manager.html#a77b408d0f8c031015235641c1117c17d">More...</a><br /></td></tr>
<tr class="separator:a77b408d0f8c031015235641c1117c17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1664b060ef25ff9d843b69613e4c8f8e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1664b060ef25ff9d843b69613e4c8f8e">copy</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;source_path, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;destination_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:a1664b060ef25ff9d843b69613e4c8f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data store synchronously. The behavior of copying a data store that is open without the read-only mode is undefined.  <a href="classmetall_1_1basic__manager.html#a1664b060ef25ff9d843b69613e4c8f8e">More...</a><br /></td></tr>
<tr class="separator:a1664b060ef25ff9d843b69613e4c8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e53b88496dc5e3dc46331877faaacba"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a5e53b88496dc5e3dc46331877faaacba">copy_async</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> source_path, const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> destination_path, const bool clone=true, const int num_max_copy_threads=0) noexcept</td></tr>
<tr class="memdesc:a5e53b88496dc5e3dc46331877faaacba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data store asynchronously. The behavior of copying a data store that is open without the read-only mode is undefined.  <a href="classmetall_1_1basic__manager.html#a5e53b88496dc5e3dc46331877faaacba">More...</a><br /></td></tr>
<tr class="separator:a5e53b88496dc5e3dc46331877faaacba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da77ef852b172cdcde1320215a536a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ad4da77ef852b172cdcde1320215a536a">remove</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:ad4da77ef852b172cdcde1320215a536a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data store synchronously.  <a href="classmetall_1_1basic__manager.html#ad4da77ef852b172cdcde1320215a536a">More...</a><br /></td></tr>
<tr class="separator:ad4da77ef852b172cdcde1320215a536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d4bbdcaae18c7c567ad3f75bf0cbb9"><td class="memItemLeft" align="right" valign="top">static std::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#aa1d4bbdcaae18c7c567ad3f75bf0cbb9">remove_async</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:aa1d4bbdcaae18c7c567ad3f75bf0cbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove data store asynchronously.  <a href="classmetall_1_1basic__manager.html#aa1d4bbdcaae18c7c567ad3f75bf0cbb9">More...</a><br /></td></tr>
<tr class="separator:aa1d4bbdcaae18c7c567ad3f75bf0cbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d19319bcc59cab74167aba6cbfe81"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a976d19319bcc59cab74167aba6cbfe81">consistent</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:a976d19319bcc59cab74167aba6cbfe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a data store exists and is consistent (i.e., it was closed properly in the previous run).  <a href="classmetall_1_1basic__manager.html#a976d19319bcc59cab74167aba6cbfe81">More...</a><br /></td></tr>
<tr class="separator:a976d19319bcc59cab74167aba6cbfe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c91b51f1ec18dc2cda0ff892f5ffd8"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab4c91b51f1ec18dc2cda0ff892f5ffd8">get_uuid</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:ab4c91b51f1ec18dc2cda0ff892f5ffd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a UUID of the data store.  <a href="classmetall_1_1basic__manager.html#ab4c91b51f1ec18dc2cda0ff892f5ffd8">More...</a><br /></td></tr>
<tr class="separator:ab4c91b51f1ec18dc2cda0ff892f5ffd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1973a7fa2d1be7ff1a6c3edb339c4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a2e1973a7fa2d1be7ff1a6c3edb339c4e">get_version</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:a2e1973a7fa2d1be7ff1a6c3edb339c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version of the Metall that created the backing data store.  <a href="classmetall_1_1basic__manager.html#a2e1973a7fa2d1be7ff1a6c3edb339c4e">More...</a><br /></td></tr>
<tr class="separator:a2e1973a7fa2d1be7ff1a6c3edb339c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88514ce1a74b52247e96e575aee824df"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a88514ce1a74b52247e96e575aee824df">set_description</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path, const std::string &amp;description) noexcept</td></tr>
<tr class="memdesc:a88514ce1a74b52247e96e575aee824df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a description to a Metall data store. An existing description is overwritten (only one description per data store).  <a href="classmetall_1_1basic__manager.html#a88514ce1a74b52247e96e575aee824df">More...</a><br /></td></tr>
<tr class="separator:a88514ce1a74b52247e96e575aee824df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a312cc228c831f5929ab695ec7c7980"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a9a312cc228c831f5929ab695ec7c7980">get_description</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path, std::string *description) noexcept</td></tr>
<tr class="memdesc:a9a312cc228c831f5929ab695ec7c7980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a description. If there is no description, nothing to happen to the given description object.  <a href="classmetall_1_1basic__manager.html#a9a312cc228c831f5929ab695ec7c7980">More...</a><br /></td></tr>
<tr class="separator:a9a312cc228c831f5929ab695ec7c7980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a808cd245fcf1708ce9f2cbe9afce3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#af8599f64b9f87fa30a0c45644d50d728">named_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4a808cd245fcf1708ce9f2cbe9afce3e">access_named_object_attribute</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:a4a808cd245fcf1708ce9f2cbe9afce3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of named objects.  <a href="classmetall_1_1basic__manager.html#a4a808cd245fcf1708ce9f2cbe9afce3e">More...</a><br /></td></tr>
<tr class="separator:a4a808cd245fcf1708ce9f2cbe9afce3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fcf0b146438ac5f8013aba701f4f0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#a1151eb95d988f6eb46a2cdeb7016048a">unique_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#ab8fcf0b146438ac5f8013aba701f4f0e">access_unique_object_attribute</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:ab8fcf0b146438ac5f8013aba701f4f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of unique object.  <a href="classmetall_1_1basic__manager.html#ab8fcf0b146438ac5f8013aba701f4f0e">More...</a><br /></td></tr>
<tr class="separator:ab8fcf0b146438ac5f8013aba701f4f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1110d24dbb9d47109f5973aa4c4c75f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmetall_1_1basic__manager.html#a4983c6a23ab89f2fd13127f78db3da51">anonymous_object_attribute_accessor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a1110d24dbb9d47109f5973aa4c4c75f4">access_anonymous_object_attribute</a> (const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;path) noexcept</td></tr>
<tr class="memdesc:a1110d24dbb9d47109f5973aa4c4c75f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance that provides access to the attribute of anonymous object.  <a href="classmetall_1_1basic__manager.html#a1110d24dbb9d47109f5973aa4c4c75f4">More...</a><br /></td></tr>
<tr class="separator:a1110d24dbb9d47109f5973aa4c4c75f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee25ee027f416bc16b06c5895d51437"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmetall_1_1basic__manager.html#a4ee25ee027f416bc16b06c5895d51437">chunk_size</a> () noexcept</td></tr>
<tr class="memdesc:a4ee25ee027f416bc16b06c5895d51437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal chunk size.  <a href="classmetall_1_1basic__manager.html#a4ee25ee027f416bc16b06c5895d51437">More...</a><br /></td></tr>
<tr class="separator:a4ee25ee027f416bc16b06c5895d51437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename storage = kernel::storage, typename segment_storage = kernel::segment_storage, typename chunk_no_type = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt;<br />
class metall::basic_manager&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;</h3>

<p>A generalized Metall manager class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">storage</td><td>Storage manager. </td></tr>
    <tr><td class="paramname">segment_storage</td><td>Segment storage manager. </td></tr>
    <tr><td class="paramname">chunk_no_type</td><td>Type of chunk number. </td></tr>
    <tr><td class="paramname">k_chunk_size</td><td>Size of single chunk in byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="adjacency_list_graph_8cpp-example.html#_a2">adjacency_list_graph.cpp</a>, <a class="el" href="allocator_aware_type_8cpp-example.html#_a2">allocator_aware_type.cpp</a>, <a class="el" href="complex_map_8cpp-example.html#_a2">complex_map.cpp</a>, <a class="el" href="concurrent_map_8cpp-example.html#_a3">concurrent_map.cpp</a>, <a class="el" href="csr_graph_8cpp-example.html#_a3">csr_graph.cpp</a>, <a class="el" href="datastore_description_8cpp-example.html#_a1">datastore_description.cpp</a>, <a class="el" href="fallback_allocator_8cpp-example.html#_a1">fallback_allocator.cpp</a>, <a class="el" href="jgraph_8cpp-example.html#_a2">jgraph.cpp</a>, <a class="el" href="json_create_8cpp-example.html#_a3">json_create.cpp</a>, <a class="el" href="json_open_8cpp-example.html#_a2">json_open.cpp</a>, <a class="el" href="logger_8cpp-example.html#_a4">logger.cpp</a>, <a class="el" href="multilevel_containers_8cpp-example.html#_a6">multilevel_containers.cpp</a>, <a class="el" href="object_attribute_8cpp-example.html#_a1">object_attribute.cpp</a>, <a class="el" href="object_attribute_api_list_8cpp-example.html#_a2">object_attribute_api_list.cpp</a>, <a class="el" href="offset_pointer_8cpp-example.html#_a1">offset_pointer.cpp</a>, <a class="el" href="simple_8cpp-example.html#_a1">simple.cpp</a>, <a class="el" href="snapshot_8cpp-example.html#_a2">snapshot.cpp</a>, <a class="el" href="string_8cpp-example.html#_a2">string.cpp</a>, <a class="el" href="string_map_8cpp-example.html#_a1">string_map.cpp</a>, and <a class="el" href="vector_of_vectors_8cpp-example.html#_a3">vector_of_vectors.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a54d169d8e19b55f60edadd4e49b75193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d169d8e19b55f60edadd4e49b75193">&#9670;&nbsp;</a></span>manager_kernel_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a> =  kernel::manager_kernel&lt;storage, segment_storage, chunk_no_type, k_chunk_size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manager kernel type. </p>

</div>
</div>
<a id="a1afedb822522743317a6f0a784a4c91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afedb822522743317a6f0a784a4c91e">&#9670;&nbsp;</a></span>void_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a1afedb822522743317a6f0a784a4c91e">void_pointer</a> =  typename manager_kernel_type::void_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Void pointer type. </p>

</div>
</div>
<a id="a3cfdb46ac3ee9102dcd768e593b9a696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfdb46ac3ee9102dcd768e593b9a696">&#9670;&nbsp;</a></span>char_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">char_type</a> =  typename manager_kernel_type::char_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Char type. </p>

</div>
</div>
<a id="a9bed532efbe211f064b741fd8efdaacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bed532efbe211f064b741fd8efdaacf">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> =  typename manager_kernel_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type. </p>

</div>
</div>
<a id="a97b847c70cc6170acccbbae479d517a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b847c70cc6170acccbbae479d517a5">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a97b847c70cc6170acccbbae479d517a5">difference_type</a> =  typename manager_kernel_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type. </p>

</div>
</div>
<a id="a3ed111708cfcb17cfc53ad968fb845d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed111708cfcb17cfc53ad968fb845d4">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a> =  <a class="el" href="classmetall_1_1stl__allocator.html">stl_allocator</a>&lt;T, <a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

</div>
</div>
<a id="a9d1ffa85cdf0b52371a3f401c75e6229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1ffa85cdf0b52371a3f401c75e6229">&#9670;&nbsp;</a></span>scoped_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename OuterT , typename... InnerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a9d1ffa85cdf0b52371a3f401c75e6229">scoped_allocator_type</a> =  <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt;<a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt;OuterT&gt;, <a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt;InnerT&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type wrapped by scoped_allocator_adaptor. </p>

</div>
</div>
<a id="ac1d7d0afc64fc115eb7db3820861c8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d7d0afc64fc115eb7db3820861c8b1">&#9670;&nbsp;</a></span>fallback_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#ac1d7d0afc64fc115eb7db3820861c8b1">fallback_allocator</a> =  <a class="el" href="classmetall_1_1container_1_1fallback__allocator__adaptor.html">container::fallback_allocator_adaptor</a>&lt;<a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A STL compatible allocator which fallbacks to a heap allocator (e.g., malloc()) if no argument is provided to construct a allocator_type instance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>This allocator enables the following code. </p><div class="fragment"><div class="line">{</div>
<div class="line"> <span class="keyword">using</span> alloc = fallback_allocator&lt;int&gt;;</div>
<div class="line"> <span class="comment">// Allocate a vector object in a heap.</span></div>
<div class="line"> vector&lt;int, alloc&gt; vec;</div>
<div class="line"> <span class="comment">// Allocate a vector object in a Metall space.</span></div>
<div class="line"> vector&lt;int, alloc&gt; vec2(<a class="code" href="namespacemetall.html#a0128ebca3d3d10b4d2db0525e8a74cf0">manager</a>.get_allocator());</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemetall_html_a0128ebca3d3d10b4d2db0525e8a74cf0"><div class="ttname"><a href="namespacemetall.html#a0128ebca3d3d10b4d2db0525e8a74cf0">metall::manager</a></div><div class="ttdeci">basic_manager&lt;&gt; manager</div><div class="ttdoc">Default Metall manager class which is an alias of basic_manager with the default template parameters.</div><div class="ttdef"><b>Definition:</b> metall.hpp:34</div></div>
</div><!-- fragment --> <dl class="section attention"><dt>Attention</dt><dd>One of the primary purposes of this allocator is to provide a way to temporarily allocate data structures that use Metall’s STL-allocator in a heap in addition to in Metall memory space. It is advised to use this allocator with caution as two memory spaces are used transparently by this allocator. </dd></dl>

</div>
</div>
<a id="ae890b76027335cee42c2c3f9c5f1c621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae890b76027335cee42c2c3f9c5f1c621">&#9670;&nbsp;</a></span>scoped_fallback_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#ae890b76027335cee42c2c3f9c5f1c621">scoped_fallback_allocator_type</a> =  <a class="el" href="namespacemetall_1_1container.html#aece4cdd0d20737ad97bb9fccac276bc5">container::scoped_allocator_adaptor</a>&lt;<a class="el" href="classmetall_1_1basic__manager.html#ac1d7d0afc64fc115eb7db3820861c8b1">fallback_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fallback allocator type wrapped by scoped_allocator_adaptor. </p>

</div>
</div>
<a id="a312c54d498f9608d0b27bcaab2240e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312c54d498f9608d0b27bcaab2240e60">&#9670;&nbsp;</a></span>construct_proxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a> =  metall::mtlldetail::named_proxy&lt;<a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a>, T, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct proxy. </p>

</div>
</div>
<a id="ad7707e4a1376bd27db5df59cfbb09c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7707e4a1376bd27db5df59cfbb09c52">&#9670;&nbsp;</a></span>construct_iter_proxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a> =  metall::mtlldetail::named_proxy&lt;<a class="el" href="classmetall_1_1basic__manager.html#a54d169d8e19b55f60edadd4e49b75193">manager_kernel_type</a>, T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct iterator proxy. </p>

</div>
</div>
<a id="a4787bd6efa19807d37ab4ae101e3ca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4787bd6efa19807d37ab4ae101e3ca7b">&#9670;&nbsp;</a></span>instance_kind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">instance_kind</a> =  typename manager_kernel_type::instance_kind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An value that describes the type of the instance constructed in memory. </p>

</div>
</div>
<a id="a7ca584b4be45b2bd5f28e458e73d9439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca584b4be45b2bd5f28e458e73d9439">&#9670;&nbsp;</a></span>const_named_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a> =  typename manager_kernel_type::const_named_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for named objects. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a0">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a762dc63d6853c1eedc7dd73e1e286423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762dc63d6853c1eedc7dd73e1e286423">&#9670;&nbsp;</a></span>const_unique_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a> =  typename manager_kernel_type::const_unique_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for unique objects. </p>

</div>
</div>
<a id="ab27f060036d966e34fe0725058787ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27f060036d966e34fe0725058787ba6">&#9670;&nbsp;</a></span>const_anonymous_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a> =  typename manager_kernel_type::const_anonymous_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator for anonymous objects. </p>

</div>
</div>
<a id="af8599f64b9f87fa30a0c45644d50d728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8599f64b9f87fa30a0c45644d50d728">&#9670;&nbsp;</a></span>named_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#af8599f64b9f87fa30a0c45644d50d728">named_object_attribute_accessor_type</a> =  typename manager_kernel_type::named_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to named object attribute. </p>

</div>
</div>
<a id="a1151eb95d988f6eb46a2cdeb7016048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1151eb95d988f6eb46a2cdeb7016048a">&#9670;&nbsp;</a></span>unique_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a1151eb95d988f6eb46a2cdeb7016048a">unique_object_attribute_accessor_type</a> =  typename manager_kernel_type::unique_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to unique object attribute. </p>

</div>
</div>
<a id="a4983c6a23ab89f2fd13127f78db3da51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4983c6a23ab89f2fd13127f78db3da51">&#9670;&nbsp;</a></span>anonymous_object_attribute_accessor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a4983c6a23ab89f2fd13127f78db3da51">anonymous_object_attribute_accessor_type</a> =  typename manager_kernel_type::anonymous_object_attr_accessor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to anonymous object attribute. </p>

</div>
</div>
<a id="a4d325cc1b5a88b580f9454533ea2fe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d325cc1b5a88b580f9454533ea2fe6e">&#9670;&nbsp;</a></span>chunk_number_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a4d325cc1b5a88b580f9454533ea2fe6e">chunk_number_type</a> =  chunk_no_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chunk number type (= chunk_no_type) </p>

</div>
</div>
<a id="a2301ccf45568d8ecc03ba2c8a1019b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2301ccf45568d8ecc03ba2c8a1019b04">&#9670;&nbsp;</a></span>path_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> =  typename manager_kernel_type::path_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Path type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4748a26a6ab4da4a807e043d515f3f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4748a26a6ab4da4a807e043d515f3f29">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1open__only__t.html">open_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing data store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a6c92e9e758f990c2f81b92c5e0fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6c92e9e758f990c2f81b92c5e0fb82">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1open__read__only__t.html">open_read_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing data store with the read only mode. Write accesses will cause segmentation fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b5a3c5820987e2941b43a425b175c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5a3c5820987e2941b43a425b175c43">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new data store (an existing data store will be overwritten). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to create a data store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe475f071a697c5d6f19ec47250392f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe475f071a697c5d6f19ec47250392f">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmetall_1_1create__only__t.html">create_only_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new data store (an existing data store will be overwritten). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_path</td><td>Path to create a data store. </td></tr>
    <tr><td class="paramname">capacity</td><td>Total allocation size. Metall uses this value as a hint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c91bf1086d26bfa83356fb9e3377df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c91bf1086d26bfa83356fb9e3377df5">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>

</div>
</div>
<a id="a6057f4d19b8480e5da499f5b92aca009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6057f4d19b8480e5da499f5b92aca009">&#9670;&nbsp;</a></span>~basic_manager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::~<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="aba83d5cdb40dbbcc7dc3920a2a3231f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba83d5cdb40dbbcc7dc3920a2a3231f0">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>

</div>
</div>
<a id="a4113d7bba77d09b862d736e114c926ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4113d7bba77d09b862d736e114c926ea">&#9670;&nbsp;</a></span>basic_manager() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::<a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f6ecf9b74ad0009d39b6a6b4e395070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6ecf9b74ad0009d39b6a6b4e395070">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&amp; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>
<dl class="section return"><dt>Returns</dt><dd>N/A. </dd></dl>

</div>
</div>
<a id="a0120b4660c0396c0795c3b5bd09c4651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120b4660c0396c0795c3b5bd09c4651">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&amp; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>An reference to the object. </dd></dl>

</div>
</div>
<a id="a14d1eb83452cdc20bfcb9f76bf45ddff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d1eb83452cdc20bfcb9f76bf45ddff">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object of type T. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)(arg1, arg2...);</div>
<div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](arg1, arg2...);</div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a3c91bf1086d26bfa83356fb9e3377df5"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">metall::basic_manager::basic_manager</a></div><div class="ttdeci">basic_manager()=delete</div><div class="ttdoc">Deleted.</div></div>
</div><!-- fragment --><p> Where, 'arg1, arg2...' are the arguments passed to T's constructor via a proxy object. One can also construct an array using '[ ]' operator. When an array is constructed, each object receives the same arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that constructs the object on the allocated space. Returns nullptr if the name was used or it failed to allocate memory. </dd></dl>

</div>
</div>
<a id="a7ce5874be956d31bcd2c3337359eca46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce5874be956d31bcd2c3337359eca46">&#9670;&nbsp;</a></span>find_or_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a312c54d498f9608d0b27bcaab2240e60">construct_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::find_or_construct </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an already constructed object. If not exist, constructs an object of type T. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.find_or_construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)(arg1, arg2...);</div>
<div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.find_or_construct&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](arg1, arg2...);</div>
</div><!-- fragment --><p> Where, 'arg1, arg2...' are the arguments passed to T's constructor via a proxy object. One can also construct an array using '[ ]' operator. When an array is constructed, each object receives the same arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that holds a pointer of an already constructed object or an object newly constructed. </dd></dl>

</div>
</div>
<a id="a3d6eb59c6e9485cf2d7d75336f34742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6eb59c6e9485cf2d7d75336f34742e">&#9670;&nbsp;</a></span>construct_it()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::construct_it </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an array of objects of type T, receiving arguments from iterators. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.construct_it&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](it1, it2...);</div>
</div><!-- fragment --><p> Each object receives parameters returned with the expression (*it1++, *it2++,... ).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object to construct an array of objects. </dd></dl>

</div>
</div>
<a id="a686bde74904756e2ba7ffb7a3b638b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686bde74904756e2ba7ffb7a3b638b5c">&#9670;&nbsp;</a></span>find_or_construct_it()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ad7707e4a1376bd27db5df59cfbb09c52">construct_iter_proxy</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::find_or_construct_it </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find an already constructed object. If not exist, constructs an array of objects of type T, receiving arguments from iterators. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<p>If T's constructor throws, the function throws that exception. Memory is freed automatically if T's constructor throws and if an array was being constructed, destructors of created objects are called before freeing the memory.</p>
<p>Example: </p><div class="fragment"><div class="line">T *ptr = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.find_or_construct_it&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>)[count](it1,</div>
<div class="line">it2...); </div>
</div><!-- fragment --><p> Each object receives parameters returned with the expression (*it1++, *it2++,... ).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A unique name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy object that holds a pointer to the already constructed object or constructs an array of objects or just holds an pointer. </dd></dl>

</div>
</div>
<a id="acfc48c56877a7feb606d3f8c08b0e5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc48c56877a7feb606d3f8c08b0e5dd">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T *, <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::find </td>
          <td>(</td>
          <td class="paramtype">char_ptr_holder_type&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find a previously created object. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">std::pair&lt;T *, std::size_t&gt; ret = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.find&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the object and the count (if it is not an array, returns 1). If not present, nullptr is returned. </dd></dl>

</div>
</div>
<a id="af0cb9dd2ed9e5b2554cb59422da8a7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cb9dd2ed9e5b2554cb59422da8a7fa">&#9670;&nbsp;</a></span>destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a previously created object. Calls the destructor and frees the memory. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.destroy&lt;T&gt;(<span class="stringliteral">&quot;Name&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. </dd></dl>

</div>
</div>
<a id="a9800fbd65ec2a7cedf05503e6194798a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9800fbd65ec2a7cedf05503e6194798a">&#9670;&nbsp;</a></span>destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">const metall::mtlldetail::unique_instance_t * const&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a unique object of type T. Calls the destructor and frees the memory. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.destroy&lt;T&gt;(metall::unique_instance);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. </dd></dl>

</div>
</div>
<a id="a35b49c024ec2944a9d6b4c4fa570a064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b49c024ec2944a9d6b4c4fa570a064">&#9670;&nbsp;</a></span>destroy_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::destroy_ptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a object (named, unique, or anonymous) by its address. Calls the destructor and frees the memory. Cannot destroy an object not allocated by construct/find_or_construct functions. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="section note"><dt>Note</dt><dd>If T's destructor throws: 1) the exception will be thrown (propagated); 2) the memory will won't be freed; 3) the object entry will be still removed from the attributed object directory. Therefore, it is not recommended to throw exception in a destructor.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> destroyed = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.destroy_ptr&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the object was not destroyed. Note that the original API developed by Boost.Interprocess library does not return value. </dd></dl>

</div>
</div>
<a id="a472a57e70e9f8ba6fefd1ee11949da23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472a57e70e9f8ba6fefd1ee11949da23">&#9670;&nbsp;</a></span>get_instance_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">char_type</a>* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_instance_name </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of an object created with construct/find_or_construct functions. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">char_type</a> name = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.get_instance_name&lt;T&gt;(ptr);</div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a3cfdb46ac3ee9102dcd768e593b9a696"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a3cfdb46ac3ee9102dcd768e593b9a696">metall::basic_manager::char_type</a></div><div class="ttdeci">typename manager_kernel_type::char_type char_type</div><div class="ttdoc">Char type.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:55</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the object. If ptr points to an unique instance, typeid(T).name() is returned. If ptr points to an anonymous instance or memory not allocated by construct/find_or_construct functions, nullptr is returned. </dd></dl>

</div>
</div>
<a id="a6654ceed688e46fa6b07ca1984436d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6654ceed688e46fa6b07ca1984436d69">&#9670;&nbsp;</a></span>get_instance_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">instance_kind</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_instance_kind </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kind of an object created with construct/find_or_construct functions. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">instance_kind</a> t = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.get_instance_kind&lt;T&gt;(ptr);</div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a4787bd6efa19807d37ab4ae101e3ca7b"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a4787bd6efa19807d37ab4ae101e3ca7b">metall::basic_manager::instance_kind</a></div><div class="ttdeci">typename manager_kernel_type::instance_kind instance_kind</div><div class="ttdoc">An value that describes the type of the instance constructed in memory.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:117</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the object. </dd></dl>

</div>
</div>
<a id="a2ff58b1a97818aa51d84219d74bb3ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff58b1a97818aa51d84219d74bb3ed5">&#9670;&nbsp;</a></span>get_instance_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_instance_length </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of an object created with construct/find_or_construct functions (1 if is a single element, &gt;=1 if it's an array). </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> length = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.get_instance_length&lt;T&gt;(ptr);</div>
<div class="ttc" id="aclassmetall_1_1basic__manager_html_a9bed532efbe211f064b741fd8efdaacf"><div class="ttname"><a href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">metall::basic_manager::size_type</a></div><div class="ttdeci">typename manager_kernel_type::size_type size_type</div><div class="ttdoc">Size type.</div><div class="ttdef"><b>Definition:</b> basic_manager.hpp:58</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type of the object. </dd></dl>

</div>
</div>
<a id="a47faa10a26dd2a7892ac7d3fc24807b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47faa10a26dd2a7892ac7d3fc24807b1">&#9670;&nbsp;</a></span>is_instance_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::is_instance_type </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the type of an object, which was created with construct/find_or_construct functions, is T. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> correct_type = <a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.type&lt;T&gt;(ptr);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A expected type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if T is correct; otherwise false. </dd></dl>

</div>
</div>
<a id="a53f88d2fbcefa2b8dba5d7894326596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f88d2fbcefa2b8dba5d7894326596a">&#9670;&nbsp;</a></span>get_instance_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_instance_description </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the description of an object created with construct/find_or_construct. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">std::string</a> description;</div>
<div class="line"><a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.get_instance_description&lt;T&gt;(ptr, &amp;description);</div>
<div class="ttc" id="anamespacemetall_1_1container_html_a5fe499903b179ed596cd8c2bd6892009"><div class="ttname"><a href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">metall::container::string</a></div><div class="ttdeci">basic_string&lt; char &gt; string</div><div class="ttdoc">A string container that uses char as its character type and Metall as its default allocator.</div><div class="ttdef"><b>Definition:</b> string.hpp:23</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramname">description</td><td>A pointer to a string buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false on error. </dd></dl>

</div>
</div>
<a id="aa662835a1039b16aeaf59cd1de1b459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa662835a1039b16aeaf59cd1de1b459c">&#9670;&nbsp;</a></span>set_instance_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::set_instance_description </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to an object created with construct/find_or_construct. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="namespacemetall_1_1container.html#a5fe499903b179ed596cd8c2bd6892009">std::string</a> description;</div>
<div class="line"><a class="code" href="classmetall_1_1basic__manager.html#a3c91bf1086d26bfa83356fb9e3377df5">basic_manager</a>.set_instance_description&lt;T&gt;(ptr, description);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramname">description</td><td>A description to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false on error. </dd></dl>

</div>
</div>
<a id="aaec8bd3463abdb8f132d931ad64abb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec8bd3463abdb8f132d931ad64abb5b">&#9670;&nbsp;</a></span>get_num_named_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_num_named_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of named objects stored in the managed segment. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of named objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="afe38f03d7a9a8d0280d887fe06571fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe38f03d7a9a8d0280d887fe06571fd7">&#9670;&nbsp;</a></span>get_num_unique_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_num_unique_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of unique objects stored in the managed segment. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unique objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="a70fec18fc8010c90726994a470efad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fec18fc8010c90726994a470efad46">&#9670;&nbsp;</a></span>get_num_anonymous_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_num_anonymous_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Returns the number of anonymous objects (objects constructed with metall::anonymous_instance) stored in the managed segment. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of anonymous objects stored in the managed segment. </dd></dl>

</div>
</div>
<a id="ad5dfa9f54756414cde0701786c5d9ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5dfa9f54756414cde0701786c5d9ddd">&#9670;&nbsp;</a></span>named_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::named_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the named objects. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the named objects. </dd></dl>

</div>
</div>
<a id="aeb5e64bc1f9dfd430cff5e0f6bf60be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5e64bc1f9dfd430cff5e0f6bf60be1">&#9670;&nbsp;</a></span>named_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a7ca584b4be45b2bd5f28e458e73d9439">const_named_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::named_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the named allocations. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="ab88e390c2d3bf12317f0ee32c1c6297e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88e390c2d3bf12317f0ee32c1c6297e">&#9670;&nbsp;</a></span>unique_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::unique_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the unique objects. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the unique objects. </dd></dl>

</div>
</div>
<a id="a63f9928024277f0c04200c2d4b94942a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f9928024277f0c04200c2d4b94942a">&#9670;&nbsp;</a></span>unique_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a762dc63d6853c1eedc7dd73e1e286423">const_unique_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::unique_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the unique allocations. </p>
<p>Attributed object construction family API developed by Boost.Interprocess <a href="https://www.boost.org/doc/libs/release/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_features.allocation_types">(see details). </a></p>
<p>A named object must be associated with non-empty name. The name of an unique object is typeid(T).name(). An anonymous object has no name. </p><dl class="section warning"><dt>Warning</dt><dd>Constructing or destroying attributed objects breaks attributed object iterators.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="a0b9eeb82c79858b194b5428adcd2036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9eeb82c79858b194b5428adcd2036f">&#9670;&nbsp;</a></span>anonymous_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::anonymous_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the index storing the anonymous objects. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator to the index storing the anonymous objects. </dd></dl>

</div>
</div>
<a id="ac191291d2ecaad2f2ad7359286ff7ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac191291d2ecaad2f2ad7359286ff7ea0">&#9670;&nbsp;</a></span>anonymous_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#ab27f060036d966e34fe0725058787ba6">const_anonymous_iterator</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::anonymous_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the end of the index storing the anonymous allocations. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator. </dd></dl>

</div>
</div>
<a id="a0ca202b915bf3c9ffeec887c1e49a7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca202b915bf3c9ffeec887c1e49a7bb">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates nbytes bytes. </p>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="af7bc00f1cd89d59407ecf7a98546bd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bc00f1cd89d59407ecf7a98546bd9e">&#9670;&nbsp;</a></span>allocate_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::allocate_aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a>&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates nbytes bytes. The address of the allocated memory will be a multiple of alignment. </p>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbytes</td><td>Number of bytes to allocate. Must be a multiple alignment.</td></tr>
    <tr><td class="paramname">alignment</td><td>Alignment size. Alignment must be a power of two and satisfy [min allocation size, chunk size]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="acf8444b4a8a137fd2b76ebb9d74ad8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8444b4a8a137fd2b76ebb9d74ad8a3">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates the allocated memory. </p>
<p>This function is thread-safe. Other threads can also call the attributed object construction functions and allocate functions simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to the allocated memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc3fb6112aef4099be115cca0c0e7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc3fb6112aef4099be115cca0c0e7b8">&#9670;&nbsp;</a></span>all_memory_deallocated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::all_memory_deallocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all allocated memory has been deallocated. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads allocate or deallocates memory at the same time.</dd></dl>
<p>This function is not cheap if many objects has not been deallocated. </p><dl class="section return"><dt>Returns</dt><dd>Returns true if all allocated memory has been deallocated; otherwise, false. </dd></dl>

</div>
</div>
<a id="a65288af3fb9b7a74bec2c7b20ca6a237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65288af3fb9b7a74bec2c7b20ca6a237">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::flush </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>synchronous</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush data to persistent memory. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe and must be called by a single thread at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synchronous</td><td>If true, performs synchronous operation; otherwise, performs asynchronous operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab483d61fda3f7acc91a22bfaddca0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab483d61fda3f7acc91a22bfaddca0686">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::snapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>destination_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a snapshot of the current data. The snapshot has a new UUID. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe and must be called by a single thread at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination_path</td><td>Path to store a snapshot. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available.</td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; other false. </dd></dl>

</div>
</div>
<a id="a1664b060ef25ff9d843b69613e4c8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1664b060ef25ff9d843b69613e4c8f8e">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>destination_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data store synchronously. The behavior of copying a data store that is open without the read-only mode is undefined. </p>
<p>This function is thread-safe.</p>
<p>Copying to the same path simultaneously is prohibited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_path</td><td>Source data store path. </td></tr>
    <tr><td class="paramname">destination_path</td><td>Destination data store path. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available.</td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If succeeded, returns true; other false. </dd></dl>

</div>
</div>
<a id="a5e53b88496dc5e3dc46331877faaacba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e53b88496dc5e3dc46331877faaacba">&#9670;&nbsp;</a></span>copy_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a>&#160;</td>
          <td class="paramname"><em>source_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a>&#160;</td>
          <td class="paramname"><em>destination_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clone</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_max_copy_threads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data store asynchronously. The behavior of copying a data store that is open without the read-only mode is undefined. </p>
<p>This function is thread-safe.</p>
<p>Copying to the same path simultaneously is prohibited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_path</td><td>Source data store path. </td></tr>
    <tr><td class="paramname">destination_path</td><td>Destination data store path. </td></tr>
    <tr><td class="paramname">clone</td><td>Use the file clone mechanism (reflink) instead of normal copy if it is available. </td></tr>
    <tr><td class="paramname">num_max_copy_threads</td><td>The maximum number of copy threads to use. If &lt;= 0 is given, the value is automatically determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an object of std::future. If succeeded, its get() returns true; other false. </dd></dl>

</div>
</div>
<a id="ad4da77ef852b172cdcde1320215a536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da77ef852b172cdcde1320215a536a">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes data store synchronously. </p>
<p>This function is thread-safe.</p>
<p>Must not remove the same data store simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If succeeded, returns true; other false. </dd></dl>

</div>
</div>
<a id="aa1d4bbdcaae18c7c567ad3f75bf0cbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d4bbdcaae18c7c567ad3f75bf0cbb9">&#9670;&nbsp;</a></span>remove_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::future&lt;bool&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::remove_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove data store asynchronously. </p>
<p>This function is thread-safe.</p>
<p>Must not remove the same data store simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to the data store to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an object of std::future. If succeeded, its get() returns true; other false </dd></dl>

</div>
</div>
<a id="a976d19319bcc59cab74167aba6cbfe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976d19319bcc59cab74167aba6cbfe81">&#9670;&nbsp;</a></span>consistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::consistent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a data store exists and is consistent (i.e., it was closed properly in the previous run). </p>
<p>This function is thread-safe.</p>
<p>Calling this function against a data store that is open without the read-only mode is undefined. If the data store is not consistent, it is recommended to remove the data store and create a new one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if it exists and is consistent; otherwise, returns false. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="simple_8cpp-example.html#a3">simple.cpp</a>, and <a class="el" href="snapshot_8cpp-example.html#a4">snapshot.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="add07703de3f86b1d3a768e71a39adc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add07703de3f86b1d3a768e71a39adc91">&#9670;&nbsp;</a></span>get_uuid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_uuid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a UUID of the data store. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>UUID in the std::string format; returns an empty string on error. </dd></dl>

</div>
</div>
<a id="ab4c91b51f1ec18dc2cda0ff892f5ffd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c91b51f1ec18dc2cda0ff892f5ffd8">&#9670;&nbsp;</a></span>get_uuid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_uuid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a UUID of the data store. </p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UUID in the std::string format; returns an empty string on error. </dd></dl>

</div>
</div>
<a id="a86f60116d08306d45700953f325ec2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f60116d08306d45700953f325ec2fb">&#9670;&nbsp;</a></span>get_version() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the version of the Metall that created the backing data store. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a version number; returns 0 on error. </dd></dl>

</div>
</div>
<a id="a2e1973a7fa2d1be7ff1a6c3edb339c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1973a7fa2d1be7ff1a6c3edb339c4e">&#9670;&nbsp;</a></span>get_version() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacemetall.html#a1ef5e73286c49c050b65d7449aea7b45">version_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_version </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the version of the Metall that created the backing data store. </p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a version number; returns 0 on error. </dd></dl>

</div>
</div>
<a id="a420e2cae534c4ab97474875d0ad7e0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e2cae534c4ab97474875d0ad7e0a6">&#9670;&nbsp;</a></span>set_description() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::set_description </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to a Metall data store. An existing description is overwritten (only one description per data store). </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not thread-safe and must be called by a single thread at a time.</dd>
<dd>
This function is not thread-safe and must be called by a single thread at a time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>An std::string object that holds a description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; otherwise, false. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="datastore_description_8cpp-example.html#a4">datastore_description.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a88514ce1a74b52247e96e575aee824df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88514ce1a74b52247e96e575aee824df">&#9670;&nbsp;</a></span>set_description() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::set_description </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a description to a Metall data store. An existing description is overwritten (only one description per data store). </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads modify the same datastore simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store.</td></tr>
    <tr><td class="paramname">description</td><td>An std::string object that holds a description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; otherwise, false. </dd></dl>

</div>
</div>
<a id="ab663057f3a9841d76e0c0359e54f5e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663057f3a9841d76e0c0359e54f5e23">&#9670;&nbsp;</a></span>get_description() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_description </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a description. If there is no description, nothing to happen to the given description object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads modify the same datastore simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>A pointer to an std::string object to store a description if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; returns false on error. Trying to get a non-existent description is not considered as an error. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="datastore_description_8cpp-example.html#a5">datastore_description.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9a312cc228c831f5929ab695ec7c7980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a312cc228c831f5929ab695ec7c7980">&#9670;&nbsp;</a></span>get_description() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_description </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a description. If there is no description, nothing to happen to the given description object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads modify the same datastore simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store.</td></tr>
    <tr><td class="paramname">description</td><td>A pointer to an std::string object to store a description if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success; returns false on error. Trying to get a non-existent description is not considered as an error. </dd></dl>

</div>
</div>
<a id="a4a808cd245fcf1708ce9f2cbe9afce3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a808cd245fcf1708ce9f2cbe9afce3e">&#9670;&nbsp;</a></span>access_named_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#af8599f64b9f87fa30a0c45644d50d728">named_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::access_named_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of named objects. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of named_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_8cpp-example.html#a4">object_attribute.cpp</a>, and <a class="el" href="object_attribute_api_list_8cpp-example.html#a5">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab8fcf0b146438ac5f8013aba701f4f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fcf0b146438ac5f8013aba701f4f0e">&#9670;&nbsp;</a></span>access_unique_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#a1151eb95d988f6eb46a2cdeb7016048a">unique_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::access_unique_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of unique object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of unique_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a6">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1110d24dbb9d47109f5973aa4c4c75f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1110d24dbb9d47109f5973aa4c4c75f4">&#9670;&nbsp;</a></span>access_anonymous_object_attribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmetall_1_1basic__manager.html#a4983c6a23ab89f2fd13127f78db3da51">anonymous_object_attribute_accessor_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::access_anonymous_object_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmetall_1_1basic__manager.html#a2301ccf45568d8ecc03ba2c8a1019b04">path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance that provides access to the attribute of anonymous object. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe as long as no other threads call non-const attributed object construction functions simultaneously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to a data store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an instance of anonymous_object_attribute_accessor_type. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="object_attribute_api_list_8cpp-example.html#a7">object_attribute_api_list.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a546acd4b653b98c8ce93527526c10151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546acd4b653b98c8ce93527526c10151">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<div class="memtemplate">
template&lt;typename T  = std::byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a3ed111708cfcb17cfc53ad968fb845d4">allocator_type</a>&lt;T&gt; <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a STL compatible allocator object. </p>
<p>This function is thread-safe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a STL compatible allocator object. </dd></dl>

</div>
</div>
<a id="a4ee25ee027f416bc16b06c5895d51437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee25ee027f416bc16b06c5895d51437">&#9670;&nbsp;</a></span>chunk_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::chunk_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal chunk size. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of internal chunk size. </dd></dl>

</div>
</div>
<a id="a2ca0c926ab3d3b0fa1d3de117704e1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca0c926ab3d3b0fa1d3de117704e1e2">&#9670;&nbsp;</a></span>get_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the address of the application data segment. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>The address of the application data segment. </dd></dl>

</div>
</div>
<a id="ab6c3a88625f83bbe60c08bd7c387a922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c3a88625f83bbe60c08bd7c387a922">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmetall_1_1basic__manager.html#a9bed532efbe211f064b741fd8efdaacf">size_type</a> <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size (i.e., the maximum total allocation size) of the application data segment. This is a theoretical value. The actual total allocation size Metall can handle will be less than that. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the application data segment. </dd></dl>

</div>
</div>
<a id="a06a7116bfa551d2b0335f26130c244de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a7116bfa551d2b0335f26130c244de">&#9670;&nbsp;</a></span>read_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::read_only </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this manager was opened as read-only. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>whether or not this manager was opened as read-only </dd></dl>

</div>
</div>
<a id="a77b408d0f8c031015235641c1117c17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b408d0f8c031015235641c1117c17d">&#9670;&nbsp;</a></span>check_sanity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename storage  = kernel::storage, typename segment_storage  = kernel::segment_storage, typename chunk_no_type  = uint32_t, std::size_t k_chunk_size = (1ULL &lt;&lt; 21ULL)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmetall_1_1basic__manager.html">metall::basic_manager</a>&lt; storage, segment_storage, chunk_no_type, k_chunk_size &gt;::check_sanity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the sanity. </p>
<p>This function is thread-safe.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if there is no issue; otherwise, returns false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/metall/metall/include/metall/<a class="el" href="basic__manager_8hpp_source.html">basic_manager.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemetall.html">metall</a></li><li class="navelem"><a class="el" href="classmetall_1_1basic__manager.html">basic_manager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
